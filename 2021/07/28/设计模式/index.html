<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="#0078E7"><meta name="author" content="John Doe"><meta name="copyright" content="John Doe"><meta name="generator" content="Hexo 5.4.0"><meta name="theme" content="hexo-theme-yun"><title>设计模式 | Hexo</title><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/star-markdown-css@0.1.25/dist/yun/yun-markdown.min.css"><script src="//at.alicdn.com/t/font_1140697_dxory92pb0h.js" async></script><script src="https://cdn.jsdelivr.net/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>document.addEventListener("DOMContentLoaded", () => {
  [".post-card",".post-content img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
});
</script><link rel="icon" href="/yun.svg"><link rel="mask-icon" href="/yun.svg" color="#0078E7"><link rel="alternate icon" href="/yun.ico"><link rel="preload" href="/css/hexo-theme-yun.css" as="style"><link rel="preload" href="/js/utils.js" as="script"><link rel="preload" href="/js/hexo-theme-yun.js" as="script"><link rel="prefetch" href="/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><script id="yun-config">
    const Yun = window.Yun || {};
    window.CONFIG = {"hostname":"example.com","root":"/","title":"逍遥一小生","version":"1.6.1","mode":"auto","copycode":true,"page":{"isPost":true},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}.","hits":"${hits} results found","hits_time":"${hits} results found in ${time} ms"},"anonymous_image":"https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/avatar/none.jpg","say":{"api":"https://v1.hitokoto.cn","hitokoto":true},"fireworks":{"colors":["102, 167, 221","62, 131, 225","33, 78, 194"]}};
  </script><link rel="stylesheet" href="/css/hexo-theme-yun.css"><script src="/js/utils.js"></script><script src="/js/hexo-theme-yun.js"></script><meta name="description" content="0 设计模式1 GoF23 一种思维，一种态度,一种进步  1 创建型模式:省去new的过程 单例模式 工厂模式 抽象工厂模式 建造者模式 原型模式。  2 结构型模式: 适配器模式 桥接模式 装饰模式 组合模式 外观模式 享元模式 代理模式  3 行为型模式: 模板方法模式 命令模式 迭代器模式 观察者模式 中介者模式 备忘录模式 解释器模式 状态模式 策略模式 职责链模式 访问者模式。  2">
<meta property="og:type" content="article">
<meta property="og:title" content="设计模式">
<meta property="og:url" content="http://example.com/2021/07/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="0 设计模式1 GoF23 一种思维，一种态度,一种进步  1 创建型模式:省去new的过程 单例模式 工厂模式 抽象工厂模式 建造者模式 原型模式。  2 结构型模式: 适配器模式 桥接模式 装饰模式 组合模式 外观模式 享元模式 代理模式  3 行为型模式: 模板方法模式 命令模式 迭代器模式 观察者模式 中介者模式 备忘录模式 解释器模式 状态模式 策略模式 职责链模式 访问者模式。  2">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2021/07/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/1584459876655.png">
<meta property="og:image" content="http://example.com/2021/07/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/1663674-20190418200726831-1746958957.png">
<meta property="og:image" content="http://example.com/2021/07/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/1663674-20190418203714266-2019816195.png">
<meta property="og:image" content="http://example.com/2021/07/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/1663674-20190418205202211-165208765.png">
<meta property="og:image" content="http://example.com/2021/07/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/1663674-20190418210010625-501405680.png">
<meta property="og:image" content="http://example.com/2021/07/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/1584146952088.png">
<meta property="og:image" content="http://example.com/2021/07/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/1584147054422.png">
<meta property="og:image" content="http://example.com/2021/07/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/1584150094662.png">
<meta property="og:image" content="http://example.com/2021/07/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/1584151724483.png">
<meta property="og:image" content="http://example.com/2021/07/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/29381f30e924b899f3cf071b3cf738900b7bf61c.jpeg">
<meta property="og:image" content="http://example.com/2021/07/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/4e4a20a4462309f7081cb61623ff29f6d6cad6bd.jpeg">
<meta property="og:image" content="http://example.com/2021/07/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/7acb0a46f21fbe0954dc66aa3a9129368544ad80.jpeg">
<meta property="og:image" content="http://example.com/2021/07/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/ac6eddc451da81cb66c0b3020297f5130b2431d4.jpeg">
<meta property="og:image" content="http://example.com/2021/07/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/8ad4b31c8701a18b16042af8cfde220d2a38fe94.jpeg">
<meta property="og:image" content="http://example.com/2021/07/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/3812b31bb051f81923afc63f8b456fe82f73e730.jpeg">
<meta property="og:image" content="http://example.com/2021/07/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/d62a6059252dd42a3b3cfd3852ca7eb0c8eab866.jpeg">
<meta property="og:image" content="http://example.com/2021/07/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/aHR0cDovL2ltYWdlLmxhaWppYW5mZW5nLm9yZy9QYWNrYWdlJTIwY2xhc3NhZGFwdGVyLnBuZw.jpg">
<meta property="og:image" content="http://example.com/2021/07/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/aHR0cDovL2ltYWdlLmxhaWppYW5mZW5nLm9yZy8yMDE4MDkxOVBhY2thZ2Vfb2JqZWN0YWRhcHRlci5wbmc.jpg">
<meta property="og:image" content="http://example.com/2021/07/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/aHR0cDovL2ltYWdlLmxhaWppYW5mZW5nLm9yZy8yMDE4MDkxOV8yMjE3LmpwZw.jpg">
<meta property="og:image" content="http://example.com/2021/07/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/aHR0cDovL2ltYWdlLmxhaWppYW5mZW5nLm9yZy8yMDE4MDkxOV8yMzMzMjcucG5n.jpg">
<meta property="og:image" content="http://example.com/2021/07/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/aHR0cDovL2ltYWdlLmxhaWppYW5mZW5nLm9yZy8yMDE4MDkxOV8yMzQzMjUucG5n.jpg">
<meta property="og:image" content="http://example.com/2021/07/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/adaf2edda3cc7cd972d6e7f14b0b033ab80e912b.jpeg">
<meta property="og:image" content="http://example.com/2021/07/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/86d6277f9e2f0708be71f1359b2e9a9ca901f29b.jpeg">
<meta property="og:image" content="http://example.com/2021/07/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/96dda144ad3459822698967f7efe13a8caef84d8.jpeg">
<meta property="og:image" content="http://example.com/2021/07/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/4afbfbedab64034f3933ea28dac95b340a551d34.jpeg">
<meta property="og:image" content="http://example.com/2021/07/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/03087bf40ad162d941398a0662d58be98b13cde1.jpeg">
<meta property="og:image" content="http://example.com/2021/07/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/1584956106705.png">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/2025309-b87a0396c5193070.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/860">
<meta property="og:image" content="http://example.com/2021/07/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/1584889615031.png">
<meta property="og:image" content="http://example.com/2021/07/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/1584628677957.png">
<meta property="og:image" content="http://example.com/2021/07/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/1584629249484.png">
<meta property="og:image" content="http://example.com/2021/07/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/5982616-094e351888095369.png">
<meta property="og:image" content="http://example.com/2021/07/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/5982616-2973c44a89da88ba.png">
<meta property="og:image" content="http://example.com/2021/07/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/1584153759373.png">
<meta property="og:image" content="http://example.com/2021/07/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/2799767-5a0e372d3b886348.webp">
<meta property="article:published_time" content="2021-07-28T03:34:12.996Z">
<meta property="article:modified_time" content="2021-07-28T03:50:10.232Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2021/07/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/1584459876655.png"><script src="/js/ui/mode.js"></script></head><body><script defer src="https://cdn.jsdelivr.net/npm/animejs@latest"></script><script defer src="/js/ui/fireworks.js"></script><canvas class="fireworks"></canvas><div class="container"><a class="sidebar-toggle hty-icon-button" id="menu-btn"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><div class="sidebar-toggle sidebar-overlay"></div><aside class="sidebar"><script src="/js/sidebar.js"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="Table of Contents"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-list-ordered"></use></svg></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="Overview"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-passport-line"></use></svg></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info mickey-mouse"><a class="site-author-avatar" href="/about/" title="John Doe"><img width="96" loading="lazy" src="/img/1.jpg" alt="John Doe"><span class="site-author-status" title="一点浩然气，千里快哉风！">😊</span></a><div class="site-author-name"><a href="/about/">John Doe</a></div><span class="site-name">Hexo</span><sub class="site-subtitle"></sub><div class="site-desciption"></div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/" title="Home"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-home-4-line"></use></svg></span></a><div class="site-state-item"><a href="/archives/" title="Archives"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-archive-line"></use></svg></span><span class="site-state-item-count">25</span></a></div><div class="site-state-item"><a href="/categories/" title="Categories"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-2-line"></use></svg></span><span class="site-state-item-count">0</span></a></div><div class="site-state-item"><a href="/tags/" title="Tags"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="site-state-item-count">0</span></a></div><a class="site-state-item hty-icon-button" target="_blank" rel="noopener" href="https://yun.yunyoujun.cn" title="文档"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-settings-line"></use></svg></span></a></nav><hr style="margin-bottom:0.5rem"><div class="links-of-author"><a class="links-of-author-item hty-icon-button" rel="noopener" href="/atom.xml" title="RSS" target="_blank" style="color:orange"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-rss-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://qm.qq.com/cgi-bin/qm/qr?k=kZJzggTTCf4SpvEQ8lXWoi5ZjhAx0ILZ&amp;jump_from=webapi" title="QQ  2038527170" target="_blank" style="color:#12B7F5"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-qq-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://github.com/qas15782/" title="GitHub" target="_blank" style="color:#6e5494"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-github-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://weibo.com/" title="微博" target="_blank" style="color:#E6162D"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-weibo-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://www.douban.com/" title="豆瓣" target="_blank" style="color:#007722"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-douban-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://music.163.com/#/user/home?id=1659649930" title="网易云音乐" target="_blank" style="color:#C20C0C"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-netease-cloud-music-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://www.zhihu.com/people/" title="知乎" target="_blank" style="color:#0084FF"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-zhihu-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://space.bilibili.com/472753721" title="哔哩哔哩" target="_blank" style="color:#FF8EB3"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-bilibili-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://cdn.jsdelivr.net" title="微信公众号" target="_blank" style="color:#1AAD19"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-wechat-2-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://twitter.com/" title="Twitter" target="_blank" style="color:#1da1f2"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-twitter-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://baidu.com" title="Telegram Channel" target="_blank" style="color:#0088CC"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-telegram-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="2038527170@qq.com" title="E-Mail" target="_blank" style="color:#8E71C1"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-mail-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://travellings.link" title="Travelling" target="_blank" style="color:var(--hty-text-color)"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-train-line"></use></svg></a></div><hr style="margin:0.5rem 1rem"><div class="links"><a class="links-item hty-icon-button" href="/links/" title="我的小伙伴们" style="color:dodgerblue"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-genderless-line"></use></svg></a></div><br><a class="links-item hty-icon-button" id="toggle-mode-btn" href="javascript:;" title="Mode" style="color: #f1cb64"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-contrast-2-line"></use></svg></a></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#0-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.</span> <span class="toc-text">0 设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-GoF23"><span class="toc-number">1.1.</span> <span class="toc-text">1 GoF23</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E7%9C%81%E5%8E%BBnew%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">1.1.1.</span> <span class="toc-text">1 创建型模式:省去new的过程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.1.2.</span> <span class="toc-text">2 结构型模式:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.1.3.</span> <span class="toc-text">3 行为型模式:</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.2.</span> <span class="toc-text">2 介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1-%E5%8E%9F%E5%88%99-%E3%80%82"><span class="toc-number">1.3.</span> <span class="toc-text">3 面向对象设计&#x3D;&#x3D;原则&#x3D;&#x3D;。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84-%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99"><span class="toc-number">1.4.</span> <span class="toc-text">4 设计模式的&#x3D;&#x3D;六大原则&#x3D;&#x3D;</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81-%E5%BC%80%E9%97%AD-%E5%8E%9F%E5%88%99%EF%BC%88Open-Close-Principle%EF%BC%89"><span class="toc-number">1.4.1.</span> <span class="toc-text">1、&#x3D;&#x3D;开闭&#x3D;&#x3D;原则（Open Close Principle）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81-%E9%87%8C%E6%B0%8F%E4%BB%A3%E6%8D%A2-%E5%8E%9F%E5%88%99%EF%BC%88Liskov-Substitution-Principle%EF%BC%89"><span class="toc-number">1.4.2.</span> <span class="toc-text">2、&#x3D;&#x3D;里氏代换&#x3D;&#x3D;原则（Liskov Substitution Principle）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81-%E4%BE%9D%E8%B5%96%E5%80%92%E8%BD%AC-%E5%8E%9F%E5%88%99%EF%BC%88Dependence-Inversion-Principle%EF%BC%89"><span class="toc-number">1.4.3.</span> <span class="toc-text">3、&#x3D;&#x3D;依赖倒转&#x3D;&#x3D;原则（Dependence Inversion Principle）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%E3%80%81-%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB-%E5%8E%9F%E5%88%99%EF%BC%88Interface-Segregation-Principle%EF%BC%89"><span class="toc-number">1.4.4.</span> <span class="toc-text">4、&#x3D;&#x3D;接口隔离&#x3D;&#x3D;原则（Interface Segregation Principle）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5%E3%80%81-%E8%BF%AA%E7%B1%B3%E7%89%B9-%E6%B3%95%E5%88%99%EF%BC%8C%E5%8F%88%E7%A7%B0%E6%9C%80%E5%B0%91%E7%9F%A5%E9%81%93%E5%8E%9F%E5%88%99%EF%BC%88Demeter-Principle%EF%BC%89"><span class="toc-number">1.4.5.</span> <span class="toc-text">5、&#x3D;&#x3D;迪米特&#x3D;&#x3D;法则，又称最少知道原则（Demeter Principle）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6%E3%80%81-%E5%90%88%E6%88%90%E5%A4%8D%E7%94%A8-%E5%8E%9F%E5%88%99%EF%BC%88Composite-Reuse-Principle%EF%BC%89"><span class="toc-number">1.4.6.</span> <span class="toc-text">6、&#x3D;&#x3D;合成复用&#x3D;&#x3D;原则（Composite Reuse Principle）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%EF%BC%88Factory-Pattern%EF%BC%89"><span class="toc-number">2.</span> <span class="toc-text">1 工厂模式（Factory Pattern）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-0-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E7%A0%94%E7%A9%B6"><span class="toc-number">2.1.</span> <span class="toc-text">1.0 工厂模式研究</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86-%E6%80%BB%E7%BB%93"><span class="toc-number">2.1.1.</span> <span class="toc-text">静态代理&#x3D;&#x3D;总结&#x3D;&#x3D;</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 动态代理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">2.2.1.</span> <span class="toc-text">&#x3D;&#x3D;总结&#x3D;&#x3D;</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-Cglib%E4%BB%A3%E7%90%86"><span class="toc-number">2.3.</span> <span class="toc-text">2.3 Cglib代理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">2.3.1.</span> <span class="toc-text">&#x3D;&#x3D;总结&#x3D;&#x3D;</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F-Bridge"><span class="toc-number">3.</span> <span class="toc-text">3 桥接模式  (Bridge)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-0-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%E6%8E%A2%E7%A9%B6"><span class="toc-number">3.1.</span> <span class="toc-text">3.0 桥接模式探究</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%A5%BD%E5%A4%84%E5%88%86%E6%9E%90-%EF%BC%9A"><span class="toc-number">3.1.1.</span> <span class="toc-text">&#x3D;&#x3D;1 好处分析&#x3D;&#x3D;：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%8A%A3%E5%8A%BF%E5%88%86%E6%9E%90-%EF%BC%9A"><span class="toc-number">3.1.2.</span> <span class="toc-text">&#x3D;&#x3D;2 劣势分析&#x3D;&#x3D;：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-number">3.1.3.</span> <span class="toc-text">&#x3D;&#x3D;3 最佳实践&#x3D;&#x3D;:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E5%9C%BA%E6%99%AF"><span class="toc-number">3.1.4.</span> <span class="toc-text">&#x3D;&#x3D;4 场景&#x3D;&#x3D;:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-%E6%80%9D%E8%80%83-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.1.5.</span> <span class="toc-text">&#x3D;&#x3D;5 思考?&#x3D;&#x3D; 桥接模式+适配器模式</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E8%AE%A4%E8%AF%86%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.2.</span> <span class="toc-text">3.1 认识桥接模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-%E5%AE%9E%E7%8E%B0%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.3.</span> <span class="toc-text">3.2 实现桥接模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-%E5%88%86%E6%9E%90%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.4.</span> <span class="toc-text">3.3 分析桥接模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%E4%B8%8D%E4%BD%BF%E7%94%A8%E7%BB%A7%E6%89%BF%E5%91%A2%EF%BC%9F"><span class="toc-number">3.4.1.</span> <span class="toc-text">1、为什么使用桥接模式不使用继承呢？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">3.4.2.</span> <span class="toc-text">2、桥接模式的优点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F-Adapter-Pattern"><span class="toc-number">4.</span> <span class="toc-text">4 适配器模式 (Adapter Pattern)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-%E7%AE%80%E4%BB%8B"><span class="toc-number">4.1.</span> <span class="toc-text">4.1 简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-%E7%A4%BA%E4%BE%8B"><span class="toc-number">4.2.</span> <span class="toc-text">4.2 示例</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E7%B1%BB%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-number">4.2.1.</span> <span class="toc-text">1 类适配器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%AF%B9%E8%B1%A1%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-number">4.2.2.</span> <span class="toc-text">2 对象适配器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E7%94%B5%E5%8E%8B%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-number">4.2.3.</span> <span class="toc-text">3 电压适配器</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93"><span class="toc-number">4.3.</span> <span class="toc-text">4.3 适配器模式总结</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E4%BC%98%E7%82%B9%EF%BC%9A"><span class="toc-number">4.3.1.</span> <span class="toc-text">主要优点：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E7%B1%BB-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E8%BF%98%E6%9C%89%E5%A6%82%E4%B8%8B-%E4%BC%98-%E7%82%B9%EF%BC%9A"><span class="toc-number">4.3.2.</span> <span class="toc-text">1 &#x3D;&#x3D;类&#x3D;&#x3D;适配器模式还有如下&#x3D;&#x3D;优&#x3D;&#x3D;点：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%AF%B9-%E8%B1%A1%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E8%BF%98%E6%9C%89%E5%A6%82%E4%B8%8B-%E4%BC%98-%E7%82%B9%EF%BC%9A"><span class="toc-number">4.3.3.</span> <span class="toc-text">2 &#x3D;&#x3D;对&#x3D;&#x3D;象适配器模式还有如下&#x3D;&#x3D;优&#x3D;&#x3D;点：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E7%B1%BB-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E7%9A%84-%E7%BC%BA-%E7%82%B9%E5%A6%82%E4%B8%8B%EF%BC%9A"><span class="toc-number">4.3.4.</span> <span class="toc-text">3 &#x3D;&#x3D;类&#x3D;&#x3D;适配器模式的&#x3D;&#x3D;缺&#x3D;&#x3D;点如下：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E5%AF%B9%E8%B1%A1-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E7%9A%84-%E7%BC%BA-%E7%82%B9%E5%A6%82%E4%B8%8B%EF%BC%9A"><span class="toc-number">4.3.5.</span> <span class="toc-text">4 &#x3D;&#x3D;对象&#x3D;&#x3D;适配器模式的&#x3D;&#x3D;缺&#x3D;&#x3D;点如下：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A"><span class="toc-number">4.3.6.</span> <span class="toc-text">适用场景：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8"><span class="toc-number">4.4.</span> <span class="toc-text">4.4 源码分析适配器模式的典型应用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-spring-AOP%E4%B8%AD%E7%9A%84%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.4.1.</span> <span class="toc-text">1 spring AOP中的适配器模式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-spring-JPA%E4%B8%AD%E7%9A%84%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.4.2.</span> <span class="toc-text">2 spring JPA中的适配器模式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-spring-MVC%E4%B8%AD%E7%9A%84%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.4.3.</span> <span class="toc-text">3 spring MVC中的适配器模式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.</span> <span class="toc-text">5 原型模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-%E8%AE%A4%E8%AF%86%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.1.</span> <span class="toc-text">5.1 认识原型模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E6%A6%82%E5%BF%B5"><span class="toc-number">5.1.1.</span> <span class="toc-text">1、概念</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81java%E7%B1%BB%E5%9B%BE%E5%88%86%E6%9E%90"><span class="toc-number">5.1.2.</span> <span class="toc-text">2、java类图分析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81%E5%88%86%E7%B1%BB"><span class="toc-number">5.1.3.</span> <span class="toc-text">3、分类</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.2.</span> <span class="toc-text">5.2 代码实现原型模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E6%AD%A5%EF%BC%9A%E5%AE%9A%E4%B9%89%E6%8A%BD%E8%B1%A1%E5%8E%9F%E5%9E%8B"><span class="toc-number">5.2.1.</span> <span class="toc-text">第一步：定义抽象原型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E6%AD%A5%EF%BC%9A%E5%AE%9A%E4%B9%89%E5%85%B7%E4%BD%93%E5%8E%9F%E5%9E%8B"><span class="toc-number">5.2.2.</span> <span class="toc-text">第二步：定义具体原型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E6%AD%A5%EF%BC%9A%E5%AE%9A%E4%B9%89%E7%94%A8%E6%88%B7%E5%8E%BB%E6%A8%A1%E6%8B%9F%E8%BF%87%E7%A8%8B"><span class="toc-number">5.2.3.</span> <span class="toc-text">第三步：定义用户去模拟过程</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-%E5%88%86%E6%9E%90%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.3.</span> <span class="toc-text">5.3 分析原型模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%8B%E9%9A%86%E5%AF%B9%E8%B1%A1%E4%B8%8D%E4%BC%9A%E8%B0%83%E7%94%A8%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">5.3.1.</span> <span class="toc-text">克隆对象不会调用构造方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E5%AF%B9%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%E6%97%A0%E6%95%88"><span class="toc-number">5.3.2.</span> <span class="toc-text">访问权限对原型模式无效</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">5.3.3.</span> <span class="toc-text">使用场景</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.</span> <span class="toc-text">6 建造者模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-0-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.1.</span> <span class="toc-text">6.0.建造者模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-%E4%BB%8B%E7%BB%8D"><span class="toc-number">6.2.</span> <span class="toc-text">6.1.介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1%E4%BB%80%E4%B9%88%E6%98%AF%E6%9E%84%E5%BB%BA%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.2.1.</span> <span class="toc-text">1.1什么是构建者模式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A"><span class="toc-number">6.2.2.</span> <span class="toc-text">1.2适用场景：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-3-%E4%B8%BB%E8%A6%81%E4%BD%9C%E7%94%A8"><span class="toc-number">6.2.3.</span> <span class="toc-text">1.3 主要作用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-4-%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">6.2.4.</span> <span class="toc-text">1.4 解决的问题</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-%E6%A8%A1%E5%BC%8F%E5%8E%9F%E7%90%86"><span class="toc-number">6.3.</span> <span class="toc-text">6.2. 模式原理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-UML%E7%B1%BB%E5%9B%BE-amp-%E7%BB%84%E6%88%90"><span class="toc-number">6.3.1.</span> <span class="toc-text">2.1 UML类图 &amp; 组成</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2%E6%A8%A1%E5%BC%8F%E8%AE%B2%E8%A7%A3%EF%BC%9A"><span class="toc-number">6.3.2.</span> <span class="toc-text">2.2模式讲解：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-%E7%94%A8-builder-%E6%A8%A1%E5%BC%8F%E5%88%9B%E5%BB%BA%E5%85%B1%E4%BA%AB%E5%8D%95%E8%BD%A6%E4%B8%BA%E4%BE%8B%E5%AD%90%EF%BC%9A"><span class="toc-number">6.4.</span> <span class="toc-text">6.3.用 builder 模式创建共享单车为例子：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E4%BA%A7%E5%93%81%E7%B1%BB%EF%BC%9A"><span class="toc-number">6.4.1.</span> <span class="toc-text">1 产品类：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-Builder-%E7%B1%BB%EF%BC%9A"><span class="toc-number">6.4.2.</span> <span class="toc-text">2  Builder 类：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-ConcreteBuilder-%E7%B1%BB"><span class="toc-number">6.4.3.</span> <span class="toc-text">3 ConcreteBuilder 类 :</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E6%8C%87%E6%8C%A5%E8%80%85%E7%B1%BB%EF%BC%9A"><span class="toc-number">6.4.4.</span> <span class="toc-text">4  指挥者类：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BD%BF%E7%94%A8%EF%BC%9A"><span class="toc-number">6.4.5.</span> <span class="toc-text">5  客户端使用：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-%E6%94%B9%E9%80%A0%E5%90%8E%E7%9A%84%E6%8A%BD%E8%B1%A1%E5%BB%BA%E9%80%A0%E8%80%85%EF%BC%9A"><span class="toc-number">6.4.6.</span> <span class="toc-text">6  改造后的抽象建造者：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-%E5%AE%A2%E6%88%B7%E7%AB%AF%EF%BC%9A"><span class="toc-number">6.4.7.</span> <span class="toc-text">7  客户端：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-%E4%BC%98%E7%BC%BA%E7%82%B9%E6%AF%94%E8%BE%83"><span class="toc-number">6.5.</span> <span class="toc-text">6.4.优缺点比较</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E7%82%B9%EF%BC%9A"><span class="toc-number">6.5.1.</span> <span class="toc-text">优点：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9%EF%BC%9A"><span class="toc-number">6.5.2.</span> <span class="toc-text">缺点：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-5-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%E4%B8%8E%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">6.6.</span> <span class="toc-text">6.5.建造者模式与抽象工厂模式的比较:</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="toc-number">7.</span> <span class="toc-text">7 抽象工厂模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-0-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="toc-number">7.1.</span> <span class="toc-text">7.0 抽象工厂模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E5%AE%9A%E4%B9%89"><span class="toc-number">7.2.</span> <span class="toc-text">7.1 抽象工厂模式定义</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E5%AE%9A%E4%B9%89"><span class="toc-number">7.2.1.</span> <span class="toc-text">1.1 抽象工厂模式定义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8FUML%E5%9B%BE"><span class="toc-number">7.2.2.</span> <span class="toc-text">1.2 抽象工厂模式UML图</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">7.3.</span> <span class="toc-text">7.2 抽象工厂模式简单实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-%E6%8A%BD%E8%B1%A1%E4%BA%A7%E5%93%81"><span class="toc-number">7.3.1.</span> <span class="toc-text">2.1 抽象产品</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2-%E5%85%B7%E4%BD%93%E4%BA%A7%E5%93%81"><span class="toc-number">7.3.2.</span> <span class="toc-text">2.2 具体产品</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82"><span class="toc-number">7.3.3.</span> <span class="toc-text">2.3 抽象工厂</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-4-%E5%85%B7%E4%BD%93%E5%B7%A5%E5%8E%82"><span class="toc-number">7.3.4.</span> <span class="toc-text">2.4 具体工厂</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-5-%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%B0%83%E7%94%A8"><span class="toc-number">7.3.5.</span> <span class="toc-text">2.5 客户端调用</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-%E4%BC%98%E7%82%B9%E5%92%8C%E7%BC%BA%E7%82%B9"><span class="toc-number">7.4.</span> <span class="toc-text">7.3 优点和缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-%E4%BC%98%E7%82%B9"><span class="toc-number">7.4.1.</span> <span class="toc-text">3.1 优点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-%E7%BC%BA%E7%82%B9"><span class="toc-number">7.4.2.</span> <span class="toc-text">3.2 缺点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-4-%E9%80%82%E7%94%A8%E7%8E%AF%E5%A2%83"><span class="toc-number">7.5.</span> <span class="toc-text">7.4 适用环境</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-5-%E6%A8%A1%E5%BC%8F%E6%89%A9%E5%B1%95"><span class="toc-number">7.6.</span> <span class="toc-text">7.5 模式扩展</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">8.</span> <span class="toc-text">8 单例模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#0-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E6%8E%A2%E7%A9%B6"><span class="toc-number">8.1.</span> <span class="toc-text">&#x3D;&#x3D;0 单例模式探究&#x3D;&#x3D;</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%A0%B8%E5%BF%83%E4%BD%9C%E7%94%A8"><span class="toc-number">8.1.1.</span> <span class="toc-text">&#x3D;&#x3D;1 核心作用&#x3D;&#x3D;:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF"><span class="toc-number">8.1.2.</span> <span class="toc-text">&#x3D;&#x3D;2 常见场景&#x3D;&#x3D;:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E4%BC%98%E7%82%B9"><span class="toc-number">8.1.3.</span> <span class="toc-text">&#x3D;&#x3D;3 优点&#x3D;&#x3D;:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E5%B8%B8%E8%A7%81%E7%9A%84%E4%BA%94%E7%A7%8D%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">8.1.4.</span> <span class="toc-text">&#x3D;&#x3D;4 常见的五种单例模式实现方式&#x3D;&#x3D;:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E7%A0%B4%E5%9D%8F%E5%8D%95%E4%BE%8B"><span class="toc-number">8.1.5.</span> <span class="toc-text">&#x3D;&#x3D;反射破坏单例&#x3D;&#x3D;</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%87%92%E6%B1%89%E6%A8%A1%E5%BC%8F"><span class="toc-number">8.2.</span> <span class="toc-text">1 懒汉模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%A5%BF%E6%B1%89%E6%A8%A1%E5%BC%8F"><span class="toc-number">8.3.</span> <span class="toc-text">2 饿汉模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%8F%8C%E9%87%8D%E9%94%81%E6%A8%A1%E5%BC%8F"><span class="toc-number">8.4.</span> <span class="toc-text">3 双重锁模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">8.5.</span> <span class="toc-text">4 静态内部类单例模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E6%9E%9A%E4%B8%BE%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">8.6.</span> <span class="toc-text">5 枚举单例模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%BD%A9%E5%9B%BE"><span class="toc-number">9.</span> <span class="toc-text">9 设计模式彩图</span></a></li></ol></div></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="hty-card post-block" itemscope itemtype="https://schema.org/Article"><link itemprop="mainEntityOfPage" href="http://example.com/2021/07/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="John Doe"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="Hexo"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">设计模式</h1><div class="post-meta"><div class="post-time" style="display:inline-block"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-line"></use></svg></span> <time title="Created: 2021-07-28 11:34:12" itemprop="dateCreated datePublished" datetime="2021-07-28T11:34:12+08:00">2021-07-28</time></div><div class="post-classify"></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content markdown-body" style="--smc-primary:#0078E7;"><h3 id="0-设计模式"><a href="#0-设计模式" class="headerlink" title="0 设计模式"></a>0 设计模式</h3><h4 id="1-GoF23"><a href="#1-GoF23" class="headerlink" title="1 GoF23"></a>1 GoF23</h4><ul>
<li>一种思维，一种态度,一种进步</li>
</ul>
<h5 id="1-创建型模式-省去new的过程"><a href="#1-创建型模式-省去new的过程" class="headerlink" title="1 创建型模式:省去new的过程"></a>1 创建型模式:省去new的过程</h5><ol>
<li>单例模式</li>
<li>工厂模式</li>
<li>抽象工厂模式</li>
<li>建造者模式</li>
<li>原型模式。</li>
</ol>
<h5 id="2-结构型模式"><a href="#2-结构型模式" class="headerlink" title="2 结构型模式:"></a>2 结构型模式:</h5><ol>
<li>适配器模式</li>
<li>桥接模式</li>
<li>装饰模式</li>
<li>组合模式</li>
<li>外观模式</li>
<li>享元模式</li>
<li>代理模式</li>
</ol>
<h5 id="3-行为型模式"><a href="#3-行为型模式" class="headerlink" title="3 行为型模式:"></a>3 行为型模式:</h5><ol>
<li>模板方法模式</li>
<li>命令模式</li>
<li>迭代器模式</li>
<li>观察者模式</li>
<li>中介者模式</li>
<li>备忘录模式</li>
<li>解释器模式</li>
<li>状态模式</li>
<li>策略模式</li>
<li>职责链模式</li>
<li>访问者模式。</li>
</ol>
<h4 id="2-介绍"><a href="#2-介绍" class="headerlink" title="2 介绍"></a>2 介绍</h4><p>==<strong>经常看源码，分析源码使用哪种设计模式，大部分情况下，都是混合使用设计模式</strong>==</p>
<ul>
<li><p>设计模式是一套被反复==使用==的、多数人==知晓==的、经过分类==编目==的、代码设计==经验==的总结。</p>
</li>
<li><p>使用设计模式是为了==重用==代码、让代码更容易被他人==理解==、保证代码==可靠性==。  </p>
</li>
<li><p>毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制==真正工程化==，设计模式是软件工程的==基石==，如同大厦的一块块砖石一样。</p>
</li>
<li><p>项目中合理地运用设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是设计模式能被广泛应用的原因。 </p>
</li>
</ul>
<h4 id="3-面向对象设计-原则-。"><a href="#3-面向对象设计-原则-。" class="headerlink" title="3 面向对象设计==原则==。"></a>3 面向对象设计==<strong>原则</strong>==。</h4><ul>
<li>对==接口==编程而不是对实现编程。</li>
<li>优先使用==对象==组合而不是继承。</li>
</ul>
<h4 id="4-设计模式的-六大原则"><a href="#4-设计模式的-六大原则" class="headerlink" title="4 设计模式的==六大原则=="></a>4 设计模式的==六大原则==</h4><h5 id="1、-开闭-原则（Open-Close-Principle）"><a href="#1、-开闭-原则（Open-Close-Principle）" class="headerlink" title="1、==开闭==原则（Open Close Principle）"></a>1、==开闭==原则（Open Close Principle）</h5><ul>
<li>开闭原则的意思是：<strong>对扩展开放，对修改关闭</strong>。</li>
<li>在程序需要进行拓展的时候，==不能去修改原有的代码==，实现一个==热插拔==的效果。</li>
<li>简言之，是为了使程序的==扩展性好==，易于 <strong>维护和升级</strong>。</li>
<li>想要达到这样的效果，我们需要使用==接口==和==抽象类==，后面的具体设计中我们会提到这点。</li>
</ul>
<h5 id="2、-里氏代换-原则（Liskov-Substitution-Principle）"><a href="#2、-里氏代换-原则（Liskov-Substitution-Principle）" class="headerlink" title="2、==里氏代换==原则（Liskov Substitution Principle）"></a>2、==里氏代换==原则（Liskov Substitution Principle）</h5><ul>
<li>里氏代换原则是==面向对象设计的基本原则之一==。 </li>
<li>里氏代换原则中说，==任何基类可以出现的地方，子类一定可以出现。==</li>
<li>LSP  是继承==复用的基石==，只有当派生类可以==替换==掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上==增加新的行为==。</li>
<li>里氏代换原则是对<code>开闭原则</code>的 ==<strong>补充</strong>==。</li>
<li>实现开闭==原则==的关键步骤就是==抽象化==，而基类与子类的 <strong>继承关系</strong> 就是抽象化的具体实现，所以里氏代换原则是对==实现==抽象化的具体步骤的规范。</li>
</ul>
<h5 id="3、-依赖倒转-原则（Dependence-Inversion-Principle）"><a href="#3、-依赖倒转-原则（Dependence-Inversion-Principle）" class="headerlink" title="3、==依赖倒转==原则（Dependence Inversion Principle）"></a>3、==依赖倒转==原则（Dependence Inversion Principle）</h5><p>  这个原则是<code>开闭原则</code>的 ==<strong>基础</strong>==，具体内容：针对接口编程，依赖于抽象而不依赖于具体。</p>
<h5 id="4、-接口隔离-原则（Interface-Segregation-Principle）"><a href="#4、-接口隔离-原则（Interface-Segregation-Principle）" class="headerlink" title="4、==接口隔离==原则（Interface Segregation Principle）"></a>4、==接口隔离==原则（Interface Segregation Principle）</h5><p>  这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：==降低==类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于 <code>升级和维护</code> 的软件设计思想，它强调==降低依赖，降低耦合。==</p>
<h5 id="5、-迪米特-法则，又称最少知道原则（Demeter-Principle）"><a href="#5、-迪米特-法则，又称最少知道原则（Demeter-Principle）" class="headerlink" title="5、==迪米特==法则，又称最少知道原则（Demeter Principle）"></a>5、==迪米特==法则，又称最少知道原则（Demeter Principle）</h5><p>  最少知道原则是指：一个实体应当尽量**==少==**地与其他实体之间发生相互作用，使得系统功能模块==相对独立==。</p>
<h5 id="6、-合成复用-原则（Composite-Reuse-Principle）"><a href="#6、-合成复用-原则（Composite-Reuse-Principle）" class="headerlink" title="6、==合成复用==原则（Composite Reuse Principle）"></a>6、==合成复用==原则（Composite Reuse Principle）</h5><p>  合成复用原则是指：尽量使用合成/聚合的方式，而==不是使用继承==。</p>
<h3 id="1-工厂模式（Factory-Pattern）"><a href="#1-工厂模式（Factory-Pattern）" class="headerlink" title="1 工厂模式（Factory Pattern）"></a>1 工厂模式（Factory Pattern）</h3><h4 id="1-0-工厂模式研究"><a href="#1-0-工厂模式研究" class="headerlink" title="1.0 工厂模式研究"></a>1.0 工厂模式研究</h4><ul>
<li><p>==<strong>作用：</strong>== </p>
<ul>
<li><strong>实现了创建者和调用者的分离</strong></li>
<li>详细分类：<ul>
<li><strong>简单工厂模式</strong></li>
<li><strong>工厂方法模式</strong></li>
<li><strong>抽象工厂模式</strong></li>
</ul>
</li>
</ul>
</li>
<li><p>==<strong>OOP 七大原则：</strong>== </p>
<ul>
<li>==开闭==原则：一个软件的实体应当<strong>对扩展开放，对修改关闭</strong> （不修改原有的代码）</li>
<li>==依赖倒转==原则：要<strong>针对接口编程</strong>，不要针对实现编程</li>
<li>==迪米特==法则：<strong>只与你直接的朋友通信</strong>，而避免和陌生人通信</li>
</ul>
</li>
<li><p>==<strong>核心本质：</strong>==</p>
<ul>
<li><strong>实例化对象不使用new，用工厂方法代替</strong></li>
<li><strong>将选择实现类，创建对象统一管理和控制。从而将调用者跟我们的实现类解耦。</strong></li>
</ul>
</li>
<li><p><strong>==三种模式：==</strong> </p>
<ul>
<li><p>==<strong>简单工厂模式</strong>==：不符合开闭原则</p>
<ul>
<li><p>用来生产同一等级结构中的<strong>任意</strong>产品（对于增加新的产品，必须扩展已有代码）</p>
</li>
<li><img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/1584459876655.png" alt="1584459876655" style="zoom: 67%; float: left;" / loading="lazy"></li>
<li><p>```java<br>//车辆<br>public interface Car {</p>
<pre><code>void name();
</code></pre>
<p>}<br>public class Tesia implements Car {</p>
<pre><code>@Override
public void name() &#123;
    // TODO Auto-generated method stub
    System.out.println(&quot;特斯拉&quot;);
&#125;
</code></pre>
<p>}<br>public class WuLing implements Car {</p>
<pre><code>@Override
public void name() &#123;
    // TODO Auto-generated method stub
    System.out.println(&quot;五菱宏光&quot;);
&#125;
</code></pre>
<p>}<br>//新增车辆<br>public class MoBai implements Car {</p>
<pre><code>@Override
public void name() &#123;
    // TODO Auto-generated method stub
    System.out.println(&quot;摩拜单车&quot;);
&#125;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  //工厂</span><br><span class="line">  //现在使用的是简单工厂模式，没有满足开闭原则：需要修改代码</span><br><span class="line">  //开闭原则：对扩展开放，对修改关闭</span><br><span class="line">  //如果再添加一辆车，这里不能修改，怎么办？——就需要工厂方法模式</span><br><span class="line">  public class CarFactory &#123;</span><br><span class="line">      //方法一</span><br><span class="line">  	public static Car getCar(String car) &#123;</span><br><span class="line">  		if (car.equals(&quot;五菱宏光&quot;)) &#123;</span><br><span class="line">  			return new WuLing();</span><br><span class="line">  		&#125;else if (car.equals(&quot;特斯拉&quot;)) &#123;</span><br><span class="line">  			return new Tesia();</span><br><span class="line">  		&#125;</span><br><span class="line">  		return null;</span><br><span class="line">  	&#125;</span><br><span class="line">      //方法二</span><br><span class="line">      public static Car getWuLing()&#123;</span><br><span class="line">          return new WuLing();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>```java<br>//消费者<br>public class Consumer {</p>
<pre><code>public static void main(String[] args) &#123;
</code></pre>
<p>//        接口，所有的实现类！<br>//        Car car=new WuLing();<br>//        Car car2=new Tesia();</p>
<p>//        使用工厂创建,在这里不需要new，不需要关心是怎么new出来的，和里面的细节</p>
<pre><code>    //方法一
    Car car= CarFactory.getCar(&quot;五菱宏光&quot;);
    Car car2= CarFactory.getCar(&quot;特斯拉&quot;);
    car.name();
    car2.name();//五菱宏光，特斯拉
    //方法二
    Car wuLing = CarFactory.getWuLing();
    wuLing.name();
&#125;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">- ==**工厂方法模式**==：符合开闭原则，但是工厂类越来越多，极其庞大</span><br><span class="line"></span><br><span class="line">  - 用来生产同一等级结构中的**固定**产品（支持增加任意产品）</span><br><span class="line"></span><br><span class="line">  - &lt;img src=&quot;%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/1584462798821.png&quot; alt=&quot;1584462798821&quot; style=&quot;zoom:67%;float:left&quot; /&gt;</span><br><span class="line"></span><br><span class="line">  - 车辆同上</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    //工厂方法模式</span><br><span class="line">    public interface CarFactory &#123;</span><br><span class="line">    	Car getCar();</span><br><span class="line">    &#125;</span><br><span class="line">    public class WulingFactory implements CarFactory &#123;</span><br><span class="line">    	@Override</span><br><span class="line">    	public Car getCar() &#123;</span><br><span class="line">    		// TODO Auto-generated method stub</span><br><span class="line">    		return new WuLing();</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //新增车辆工厂实现类</span><br><span class="line">    public class MoBaiFactory implements CarFactory &#123;</span><br><span class="line">    	@Override</span><br><span class="line">    	public Car getCar() &#123;</span><br><span class="line">    		// TODO Auto-generated method stub</span><br><span class="line">    		return new MoBai();</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>```java<br>//消费者<br>public class Consumer {</p>
<pre><code>public static void main(String[] args) &#123;
    Car car = new WulingFactory().getCar();
    Car car2 = new TeslaFactory().getCar();
    
    car.name();
    car2.name();
    
</code></pre>
<p>//        新增车辆:符合开闭原则，添加两个类</p>
<pre><code>    Car car3 = new MoBaiFactory().getCar();
    car3.name();
&#125;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 以上两种工厂模式哪个比较==好==：</span><br><span class="line"></span><br><span class="line">    - 结构复杂度：简单工厂模式</span><br><span class="line">    - 代码复杂度：简单工厂模式</span><br><span class="line">    - 编程复杂度：简单工厂模式</span><br><span class="line">    - 管理上的复杂度：简单工厂模式</span><br><span class="line">    - 根据设计原则：工厂方法模式</span><br><span class="line">    - 根据实际业务：简单工厂模式</span><br><span class="line"></span><br><span class="line">  - ==**抽象工厂模式**== </span><br><span class="line"></span><br><span class="line">    - 围绕一个**超级工厂创建其他工厂**。该超级工厂又称为其他工厂的工厂</span><br><span class="line"></span><br><span class="line">    - 涉及到两个维度</span><br><span class="line"></span><br><span class="line">      &lt;img src=&quot;%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/1584462870845.png&quot; alt=&quot;1584462870845&quot; style=&quot;zoom:67%;float:left&quot; /&gt;</span><br><span class="line"></span><br><span class="line">- ==**小结:**== </span><br><span class="line"></span><br><span class="line">  - 简单工厂模式(静态工厂模式) </span><br><span class="line">    - 虽然某种程度上不符合设计原则，但实际使用最多!</span><br><span class="line">  - 工厂方法模式</span><br><span class="line">    - 不修改已有类的前提下，通过增加新的工厂类实现扩展</span><br><span class="line">  - 抽象工厂模式</span><br><span class="line">    - 不可以增加产品(只负责工厂)，可以增加产品族!</span><br><span class="line">  - ==应用场景:== </span><br><span class="line">    1. JDK中Calendar的getInstance方法</span><br><span class="line">    2. JDBC中的Connection对象的获取</span><br><span class="line">    3. Spring中IOC容器创建管理bean对象</span><br><span class="line">    4. 反射中Class对象的newlnstance方法</span><br><span class="line"></span><br><span class="line">#### 1.1 介绍</span><br><span class="line"></span><br><span class="line">- 工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一, 工厂模式是我们最常用的==实例化对象==模式了。</span><br><span class="line">- 这种类型的设计模式属于==创建型==模式，它提供了一种==创建对象==的最佳方式。</span><br><span class="line">- 在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个==共同的接口==来指向新创建的对象。</span><br><span class="line">-  工厂模式是我们最常用的==实例化对象==模式了，是用==工厂方法代替new==操作的一种模式。</span><br><span class="line">- 著名的Jive论坛  ,就大量使用了工厂模式，工厂模式在Java程序系统可以说是随处可见。</span><br><span class="line">- 因为工厂模式就相当于==创建实例对象的new==，我们经常要根据类Class生成实例对象，</span><br><span class="line">- 如A a=new A()  工厂模式也是用来创建实例对象的，所以以后==new时就要多个心眼==，是否可以考虑使用工厂模式，虽然这样做，可能多做一些工作，但会给你系统带来更大的可扩展性和尽量少的修改量。 </span><br><span class="line">- **==本质： 工厂方法代替new操作==** </span><br><span class="line"></span><br><span class="line">**应用实例：** </span><br><span class="line"></span><br><span class="line">1. 您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。 </span><br><span class="line"></span><br><span class="line">2. Hibernate 换数据库只需换方言和驱动就可以。 </span><br><span class="line"></span><br><span class="line">**优点：** </span><br><span class="line"></span><br><span class="line">1. 一个调用者想创建一个对象，只要==知道其名称==就可以了。  </span><br><span class="line"></span><br><span class="line">2. ==扩展性高==，如果想增加一个产品，只要扩展一个工厂类就可以。 </span><br><span class="line"></span><br><span class="line">3. ==屏蔽==产品的具体实现，调用者==只关心==产品的接口。 </span><br><span class="line"></span><br><span class="line">**缺点：**每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中==类的个数成倍增加==，在一定程度上增加了系统的==复杂度==，同时也增加了系统==具体类的依赖==。这并不是什么好事。</span><br><span class="line"></span><br><span class="line">**使用场景：** </span><br><span class="line"></span><br><span class="line">1. **日志记录器**：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。 </span><br><span class="line">2. **数据库访问**，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。 </span><br><span class="line">3. 设计一个连接服务器的框架，需要三个协议，&quot;POP3&quot;、&quot;IMAP&quot;、&quot;HTTP&quot;，可以把这三个作为产品类，共同实现一个接口。 </span><br><span class="line"></span><br><span class="line">**注意事项：**作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。</span><br><span class="line"></span><br><span class="line">#### 1.2 实现</span><br><span class="line"></span><br><span class="line">我们将创建一个 *Shape* 接口和实现 *Shape* 接口的实体类。下一步是定义工厂类 *ShapeFactory*。</span><br><span class="line"></span><br><span class="line">*FactoryPatternDemo*，我们的演示类使用 *ShapeFactory* 来获取 *Shape* 对象。它将向 *ShapeFactory* 传递信息（*CIRCLE / RECTANGLE / SQUARE*），以便获取它所需对象的类型。</span><br><span class="line"></span><br><span class="line"> ![22](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/factory_pattern_uml_diagram.jpg) </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 2 代理模式  (Proxy Pattern)</span><br><span class="line"></span><br><span class="line">- 代理(Proxy)是一种设计模式,提供了 ==间接== 对目标对象进行 **访问** 的方式;</span><br><span class="line">- 即通过代理对象==访问==目标对象.</span><br><span class="line">- 这样做的==好处==是:可以在目标对象实现的功能上,==增加==额外的功能补充,即==扩展==目标对象的功能.</span><br><span class="line"></span><br><span class="line">- 这就符合了设计模式的==开闭原则==，即在对既有代码不改动的情况下进行功能的扩展。</span><br><span class="line"></span><br><span class="line">- 举个例子来说明代理的作用:明星与经纪人之间就是被代理和代理的关系,明星出演活动的时候，明星就是一个目标对象,他只要负责活动中的节目,而其他琐碎的事情就交给他的代理人(经纪人)</span><br><span class="line"></span><br><span class="line">- 来解决.这就是代理思想在现实中的一个例子。</span><br><span class="line"></span><br><span class="line">#### 2.1 静态代理</span><br><span class="line"></span><br><span class="line">- 在使用静态代理时,被代理对象与代理对象需要一起实现相同的接口或者是继承相同父类，因此要定义一个接口或抽象类.</span><br><span class="line"></span><br><span class="line">- 代码案例：</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">// 接口</span><br><span class="line">interface IStar &#123;</span><br><span class="line">    void sing();</span><br><span class="line">&#125;</span><br><span class="line">// 真实对象</span><br><span class="line">class LDHStar implements IStar &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void sing() &#123;</span><br><span class="line">        System.out.println(&quot;刘德华唱歌&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 代理类需要有真实对象的控制权 (引用)</span><br><span class="line">class ProxyManger implements IStar &#123;        </span><br><span class="line">    // 真实对象的引用</span><br><span class="line">    private IStar star;        </span><br><span class="line">    public ProxyManger() &#123;</span><br><span class="line">        super();</span><br><span class="line">    &#125;</span><br><span class="line">    public ProxyManger(IStar star) &#123;</span><br><span class="line">        super();</span><br><span class="line">        this.star = star;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void sing() &#123;　　　　　　</span><br><span class="line">        System.out.println(&quot;唱歌前准备&quot;);    　　　 </span><br><span class="line">        star.sing();   　　　　</span><br><span class="line">        System.out.println(&quot;善后工作&quot;);        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Test&#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 创建明星对象</span><br><span class="line">        IStar ldh = new LDHStar();</span><br><span class="line">        ProxyManger proxy = new ProxyManger(ldh);</span><br><span class="line">        proxy.sing();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/1663674-20190418200726831-1746958957.png" alt="img" loading="lazy"></p>
<h5 id="静态代理-总结"><a href="#静态代理-总结" class="headerlink" title="静态代理==总结=="></a>静态代理==总结==</h5><ul>
<li><p>优点：可以做到在不修改目标对象的功能前提下,对目标功能扩展.</p>
</li>
<li><p>缺点:因为代理对象需要与目标对象实现一样的接口,所以会有很多代理类,类太多.同时,一旦接口增加方法,目标对象与代理对象都要维护.</p>
</li>
<li><p><strong>而动态代理方式可以解决上面的问题</strong> </p>
</li>
</ul>
<h4 id="2-2-动态代理"><a href="#2-2-动态代理" class="headerlink" title="2.2 动态代理"></a>2.2 动态代理</h4><ul>
<li><p>动态代理的==主要特点==就是能够在程序运行时 ==<strong>JVM</strong>== 才为目标对象生成代理对象。</p>
</li>
<li><p>常说的动态代理也叫做 ==JDK代理== 也是一种 ==接口代理==，</p>
</li>
<li><p>JDK中生成代理对象的代理类就是Proxy，所在包是java.lang.reflect*<br>*</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//目标类接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IDog</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;               </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//目标类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GunDog</span> <span class="keyword">implements</span> <span class="title">IDog</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;猎狗在跑&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DogUtils</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;增强方式一&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;增强方式二&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyInvocationHandle</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTarget</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> </span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        DogUtils.method1();</span><br><span class="line">        method.invoke(target, args);</span><br><span class="line">        DogUtils.method2();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//生产代理对象的工厂</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyProxyFactory</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getProxy</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        MyInvocationHandle handle = <span class="keyword">new</span> MyInvocationHandle();</span><br><span class="line">        handle.setTarget(target);</span><br><span class="line">        Object proxy = Proxy.newProxyInstance(target.getClass().getClassLoader(), </span><br><span class="line">            target.getClass().getInterfaces(), handle);</span><br><span class="line">        <span class="keyword">return</span> proxy;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      IDog dog = <span class="keyword">new</span> GunDog();</span><br><span class="line">      IDog proxy =(IDog) MyProxyFactory.getProxy(dog);</span><br><span class="line">      proxy.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/1663674-20190418203714266-2019816195.png" alt="img" loading="lazy"></p>
<h5 id="总结"><a href="#总结" class="headerlink" title="==总结=="></a>==总结==</h5><ul>
<li>==代理对象不需要实现接口==,但是目标对象一定要实现接口,否则不能使用动态代理，因此这也算是这种方式的缺陷。</li>
</ul>
<h4 id="2-3-Cglib代理"><a href="#2-3-Cglib代理" class="headerlink" title="2.3 Cglib代理"></a>2.3 Cglib代理</h4><ul>
<li><p>上面的静态代理和动态代理模式有个相同点就是都 ==要求目标对象是实现一个接口的对象==,</p>
</li>
<li><p>然而并不是任何对象都会实现一个接口，也存在没有实现任何的接口的对象,</p>
</li>
<li><p>这时就可以使用 ==继承目标类== 以目标对象 <strong>子类</strong> 的方式==实现代理==,这种方法就叫做:==<strong>Cglib代理</strong>==，也叫作==<strong>子类代理</strong>==,它是在==内存==中==构建==一个子类对象从而实现对目标对象功能的扩展.</p>
</li>
<li><p>**使用 ==JDK动态代理== 有一个==限制==,就是被代理的对象==必须实现==一个或多个接口,若想代理==没有实现==接口的类,就需要使用==Cglib实现==. ** </p>
</li>
<li><p>由于Cglib是 ==第三方== 提供的所以使用的时候需要导入相关的jar包，有两个包如图：</p>
</li>
</ul>
<p><img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/1663674-20190418205202211-165208765.png" alt="img" loading="lazy"></p>
<ul>
<li>代码案例</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">public class CglibProxy &#123;</span><br><span class="line">    public static void main(String[] args) &#123;        </span><br><span class="line">        int[] arr = new int[100000];</span><br><span class="line">        for (int i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">            arr[i] = (int) (Math.random() * 1000);</span><br><span class="line">        &#125;</span><br><span class="line">        //实例化一个增强器，也就是cglib中的一个class generator</span><br><span class="line">        Enhancer enhancer = new Enhancer();</span><br><span class="line">        //设置目标类</span><br><span class="line">        enhancer.setSuperclass(ArraySort2.class);</span><br><span class="line">        //设置拦截对象，这里直接使用匿名内部类写法</span><br><span class="line">        enhancer.setCallback(new MethodInterceptor() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public Object intercept(Object object , Method method, Object[] args, </span><br><span class="line">            		MethodProxy proxy) throws Throwable &#123;</span><br><span class="line">                String sortName = method.getName();</span><br><span class="line">                switch (sortName) &#123;</span><br><span class="line">                    case &quot;bubbleSort&quot;:</span><br><span class="line">                        sortName = &quot;冒泡排序&quot;;</span><br><span class="line">                        break;</span><br><span class="line">                    case &quot;selectSort&quot;:</span><br><span class="line">                        sortName = &quot;选择排序&quot;;</span><br><span class="line">                        break;</span><br><span class="line">                    case &quot;quickSort&quot;:</span><br><span class="line">                        sortName = &quot;快速排序&quot;;</span><br><span class="line">                        break;</span><br><span class="line">                    default:</span><br><span class="line">                        break;</span><br><span class="line">                &#125;</span><br><span class="line">                long start = System.currentTimeMillis();</span><br><span class="line">                //此处一定要使用proxy的invokeSuper方法来调用目标类的方法</span><br><span class="line">                proxy.invokeSuper(object, args);</span><br><span class="line">                long end = System.currentTimeMillis();</span><br><span class="line">                System.out.println(&quot;本次&quot; + sortName + &quot;的执行时间为: &quot; + </span><br><span class="line">                	(end -start) + &quot;ms&quot;);</span><br><span class="line">                return null;</span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;);</span><br><span class="line">        //生成代理类并返回一个实例</span><br><span class="line">        ArraySort2 arraySort = (ArraySort2) enhancer.create();</span><br><span class="line">        arraySort.bubbleSort(arr);</span><br><span class="line">        arraySort.selectSort(arr);</span><br><span class="line">        arraySort.quickSort(arr);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">class ArraySort2&#123;</span><br><span class="line">    public void quickSort(int[] arr) &#123;</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">    &#125;</span><br><span class="line">    public void selectSort(int[] arr) &#123;</span><br><span class="line">        for (int i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">            for (int j = i+1; j &lt; arr.length; j++) &#123;</span><br><span class="line">                if (arr[i] &gt; arr[j]) &#123;</span><br><span class="line">                    int temp = 0;</span><br><span class="line">                    temp = arr[i];</span><br><span class="line">                    arr[i] = arr[j];</span><br><span class="line">                    arr[j] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void bubbleSort(int[] arr) &#123;</span><br><span class="line">        for (int i = 0; i &lt; arr.length - 1; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; arr.length - 1 - i; j++) &#123;</span><br><span class="line">                if (arr[j] &gt; arr[j + 1]) &#123;</span><br><span class="line">                    int temp = 0;</span><br><span class="line">                    temp = arr[j];</span><br><span class="line">                    arr[j] = arr[j + 1];</span><br><span class="line">                    arr[j + 1] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/1663674-20190418210010625-501405680.png" alt="img" loading="lazy"></p>
<h5 id="总结-1"><a href="#总结-1" class="headerlink" title="==总结=="></a>==总结==</h5><ul>
<li>在Spring的AOP编程中:<ul>
<li>如果加入容器的目标对象有实现接口,用JDK代理</li>
<li>如果目标对象没有实现接口,用Cglib代理。</li>
</ul>
</li>
</ul>
<h3 id="3-桥接模式-Bridge"><a href="#3-桥接模式-Bridge" class="headerlink" title="3 桥接模式  (Bridge)"></a>3 桥接模式  (Bridge)</h3><h4 id="3-0-桥接模式探究"><a href="#3-0-桥接模式探究" class="headerlink" title="3.0 桥接模式探究"></a>3.0 桥接模式探究</h4><p>我们都去买过手机，手机按照品牌分可以分为华为、小米、oppo、vivo等品牌，如果这些手机按照内存分又可以分为4G、6G、8G等等。假如我们每一种手机都想要玩一下，至少需要4*3个。这对我们来说这些手机也太多了，竟然有12个，最主要的是手机品牌和内存是放在一起的。现在有这样一种机制，手机牌品商是一个公司，做手机内存的是一个公司，想要做什么手机我们只需要让其两者搭配起来即可。有点类似于全球贸易分工明确的思想，这就是桥接模式，==把两个不同维度的东西桥接起来。== </p>
<img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/1584146952088.png" alt="1584146952088" style="zoom: 50%;" / loading="lazy">

<img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/1584147054422.png" alt="1584147054422" style="zoom: 50%;" / loading="lazy">

<img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/1584150094662.png" alt="1584150094662" style="zoom:67%;" / loading="lazy">

<h5 id="1-好处分析-："><a href="#1-好处分析-：" class="headerlink" title="==1 好处分析==："></a>==1 好处分析==：</h5><ul>
<li>桥接模式偶尔类似于多继承方案，</li>
<li>但是==多继承方案==违背了类的单一职责原则，复用性比较差，类的个数也非常多，</li>
<li>==桥接模式==是比多继承方案更好的解决方法。极大的减少了子类的个数，从而降低管理和维护的成本</li>
<li>桥接模式提高了系统的可扩充性，在两个变化维度中==任意扩展==一个维度，都==不需要修改==原有系统。</li>
<li>符合==开闭原则==，就像一座桥，可以把两个**==变化==的维度**连接起来!</li>
</ul>
<h5 id="2-劣势分析-："><a href="#2-劣势分析-：" class="headerlink" title="==2 劣势分析==："></a>==2 劣势分析==：</h5><ul>
<li>桥接模式的引入会==增加系统的理解与设计难度==，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。</li>
<li>桥接模式要求正确识别出系统中==两个独立变化==的维度（如果耦合性太高，无法抽离，不适合使用），因此其==使用范围==具有一定的局限性。</li>
</ul>
<h5 id="3-最佳实践"><a href="#3-最佳实践" class="headerlink" title="==3 最佳实践==:"></a>==3 最佳实践==:</h5><ul>
<li>如果个系统需要在构建的==抽象化==角色和==具体化==角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。 </li>
<li>抽象化角色和实现化角色可以以 <strong>继承的方式独立扩展而互不影响</strong>，</li>
<li>在程序运行时可以动态将一个抽象化子类的对象和一 个实现化子类的对象进行组合，即系统需要对抽象化角色和实现化角色进行==动态耦合==。</li>
<li><strong>一个类存在两个独立变化的维度，且这两个维度都需要进行扩展</strong>。</li>
<li>虽然在系统中使用继承是没有问题的，但是由于抽象化角色和具体化角色需要独立变化，<strong>设计要求需要独立管理这两者</strong>。</li>
<li><strong>对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。</strong> </li>
</ul>
<h5 id="4-场景"><a href="#4-场景" class="headerlink" title="==4 场景==:"></a>==4 场景==:</h5><ul>
<li><p><strong>Java语言通过Java虚拟机实现了 平台的无关性：</strong> 写的代码是一样的，但是在不同的系统上跑出来的效果是不一样的</p>
<p><img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/1584151724483.png" alt="1584151724483" loading="lazy"></p>
</li>
<li><p><strong>AWT中的Peer架构</strong></p>
</li>
<li><p><strong>JDBC驱动程序也是桥接模式的应用之一.</strong> </p>
</li>
</ul>
<h5 id="5-思考-桥接模式-适配器模式"><a href="#5-思考-桥接模式-适配器模式" class="headerlink" title="==5 思考?== 桥接模式+适配器模式"></a>==5 思考?== 桥接模式+适配器模式</h5><ul>
<li>如果八竿子打不着，可以使用适配器</li>
<li>我们学的模式是可以共用的</li>
</ul>
<h4 id="3-1-认识桥接模式"><a href="#3-1-认识桥接模式" class="headerlink" title="3.1 认识桥接模式"></a>3.1 认识桥接模式</h4><p><strong>1、概念</strong></p>
<ul>
<li>将==<strong>抽象</strong>==部分与它==<strong>实现</strong>==部分==分离==，使它们都可以==独立地变化==。</li>
<li>它是一种对象结构模式，又称为柄体（Handle and Body）模式或接口（Interface）模式</li>
</ul>
<p><strong>2、例子说明</strong> </p>
<p>从上面的例子我们可以看到，我们的手机可以从两个维度进行变化，一个是品牌，一个是内存。此时我们就可以通过桥接模式将这两个维度分离开来，每一个维度都可以独立扩展。比如说手机品牌，可以又出现了苹果、三星、锤子等等。内存方面又可以生产10G、16G的了。从专业的角度来看可以这样定义桥接模式：</p>
<p>桥接模式是一种很实用的结构型设计模式，如果软件系统中某个类存在两个独立变化的维度，通过该模式可以将这两个维度分离出来，使两者可以独立扩展，让系统更加符合“单一职责原则”。</p>
<p><strong>3、类图</strong></p>
<p>上面的例子我们画一张类图来表示一下：</p>
<p><img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/29381f30e924b899f3cf071b3cf738900b7bf61c.jpeg" alt="img" loading="lazy"></p>
<p>基本上意思就是这，也就是我们买手机的时候有两个维度可供我们选择:一个是品牌一个是内存。</p>
<p>（1）client:指的是我们买手机的人。</p>
<p>（2）Abstraction（抽象类）：指的是手机抽象类</p>
<p>（3）Refined Abstraction（具体类）：指的是具体手机品牌</p>
<p>（4）Implementor：在这里相当于手机的其他组件，内存</p>
<p>（5）ConcreteImplementor：具体的内存型号。</p>
<p>下面我们就使用代码来实现一下。</p>
<h4 id="3-2-实现桥接模式"><a href="#3-2-实现桥接模式" class="headerlink" title="3.2 实现桥接模式"></a>3.2 实现桥接模式</h4><p>第一步：定义Implementor，这里定义手机内存<strong>接口</strong></p>
<p><img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/4e4a20a4462309f7081cb61623ff29f6d6cad6bd.jpeg" alt="img" loading="lazy"></p>
<p>第二步：定义ConcreteImplementor，这里指<strong>具体</strong>的内存</p>
<p>内存这里定义了两种一种是6G，一种是8G</p>
<p><img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/7acb0a46f21fbe0954dc66aa3a9129368544ad80.jpeg" alt="img" loading="lazy"></p>
<p>第三步：定义Abstraction手机<strong>抽象类</strong></p>
<p><img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/ac6eddc451da81cb66c0b3020297f5130b2431d4.jpeg" alt="img" loading="lazy"></p>
<p>第四步：定义Refined Abstraction（<strong>具体</strong>的手机品牌）</p>
<p>首先是华为</p>
<p><img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/8ad4b31c8701a18b16042af8cfde220d2a38fe94.jpeg" alt="img" loading="lazy"></p>
<p>然后是小米</p>
<p><img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/3812b31bb051f81923afc63f8b456fe82f73e730.jpeg" alt="img" loading="lazy"></p>
<p>第五步：测试一下</p>
<p><img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/d62a6059252dd42a3b3cfd3852ca7eb0c8eab866.jpeg" alt="img" loading="lazy"></p>
<p>从代码就可以看出，购买手机的时候，品牌和内存两个维度是分开的。下面我们分析一下这个桥接模式</p>
<h4 id="3-3-分析桥接模式"><a href="#3-3-分析桥接模式" class="headerlink" title="3.3 分析桥接模式"></a>3.3 分析桥接模式</h4><h5 id="1、为什么使用桥接模式不使用继承呢？"><a href="#1、为什么使用桥接模式不使用继承呢？" class="headerlink" title="1、为什么使用桥接模式不使用继承呢？"></a>1、为什么使用桥接模式不使用继承呢？</h5><ul>
<li>==继承是一种强耦合关系==，<strong>子类与父类有非常紧密的依赖关系，父类的任何变化 都会导致子类发生变化。</strong></li>
<li>因此才使用桥接模式， 使用了桥接模式之后 ，我们的两个维度就像桥梁一样被链接了起来。</li>
<li>体现了==松耦合==的特性。</li>
</ul>
<h5 id="2、桥接模式的优点"><a href="#2、桥接模式的优点" class="headerlink" title="2、桥接模式的优点"></a>2、桥接模式的优点</h5><p>（1）==分离==抽象和实现部分：把手机、内存抽象出来。实现与之分离。</p>
<p>（2）==松耦合==：两个维度分开</p>
<p>（3）==单一==职责原则：每个维度各干各的活</p>
<p>关于桥接模式的使用场景我觉得你只需要知道他的思想，然后在遇到问题的时候能够想到这种模式即可。</p>
<h3 id="4-适配器模式-Adapter-Pattern"><a href="#4-适配器模式-Adapter-Pattern" class="headerlink" title="4 适配器模式 (Adapter Pattern)"></a>4 适配器模式 (Adapter Pattern)</h3><h4 id="4-1-简介"><a href="#4-1-简介" class="headerlink" title="4.1 简介"></a>4.1 简介</h4><ul>
<li><p>适配器模式(Adapter Pattern)：将一个接口==转换==成客户希望的另一个接口，使接口==不兼容==的那些类==可以==一起工作，其别名为==包装器(Wrapper)==。</p>
</li>
<li><p>适配器模式既可以作为==类结构==型模式，也可以作为==对象结构==型模式。</p>
</li>
<li><p>在适配器模式中，我们通过增加一个新的适配器类来 ==<strong>解决接口不兼容的问题</strong>==，使得原本没有任何关系的类可以协同工作。</p>
</li>
<li><p>根据适配==器==类与适配==者==类的==关系不同==</p>
<ul>
<li>适配==器==模式可分为==对象==适配器和==类==适配器两种<ul>
<li>在==对象==适配器模式中，适配器与适配==者==之间是==关联==关系</li>
<li>在==类==适配器模式中，适配器与适配==者==之间是==继承（或实现）==关系。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>==角色==</strong></p>
<ul>
<li><strong>Target（目标抽象类）</strong>：目标抽象类定义客户所需接口，可以是一个抽象类或接口，也可以是具体类。</li>
<li><strong>Adapter（适配==器==类）</strong>：适配器可以调用另一个接口，作为一个转换器，对Adaptee和Target进行适配，适配器类是适配器模式的核心，在对象适配器中，它通过继承Target并关联一个Adaptee对象使二者产生联系。</li>
<li><strong>Adaptee（适配==者==类）</strong>：适配者即被适配的角色，它定义了一个已经存在的接口，这个接口需要适配，适配者类一般是一个具体类，包含了客户希望使用的业务方法，在某些情况下可能没有适配者类的源代码。</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>==缺省==适配==器==模式(Default Adapter Pattern)：当==不需要实现==一个接口所提供的所有方法时，可先==设计==一个抽象类实现该接口，并为接口中每个方法==提供==一个默认实现（空方法），那么该抽象类的子类可以选择性地覆盖父类的某些方法来实现需求，<ul>
<li>它适用于不想使用一个接口中的所有方法的情况，又称为==单接口==适配器模式。</li>
<li>缺省适配器模式是适配器模式的一种==变体==，其应用也较为广泛。</li>
<li>在JDK类库的==事件处理包==java.awt.event中广泛使用了缺省适配器模式，</li>
<li>如WindowAdapter、KeyAdapter、MouseAdapter等。</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="4-2-示例"><a href="#4-2-示例" class="headerlink" title="4.2 示例"></a>4.2 示例</h4><h5 id="1-类适配器"><a href="#1-类适配器" class="headerlink" title="1 类适配器"></a>1 类适配器</h5><ul>
<li>首先有一个已存在的将被适配的类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adaptee</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">adapteeRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;被适配者的方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>定义一个目标接口</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>怎么才可以在目标接口中的 request() 调用 Adaptee 的 adapteeRequest() 方法呢？</strong></p>
<ul>
<li>如果直接实现 Target 是不行的</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteTarget</span> <span class="keyword">implements</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;concreteTarget目标方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果通过一个适配器类，实现 Target 接口，同时继承了 Adaptee 类，然后在实现的 request() 方法中调用父类的 adapteeRequest() 即可实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">extends</span> <span class="title">Adaptee</span> <span class="keyword">implements</span> <span class="title">Target</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...一些操作...</span></span><br><span class="line">        <span class="keyword">super</span>.adapteeRequest();</span><br><span class="line">        <span class="comment">//...一些操作...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>我们来测试一下</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Target target = <span class="keyword">new</span> ConcreteTarget();</span><br><span class="line">        target.request();</span><br><span class="line"></span><br><span class="line">        Target adapterTarget = <span class="keyword">new</span> Adapter();</span><br><span class="line">        adapterTarget.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>输出</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">concreteTarget目标方法</span><br><span class="line">被适配者的方法</span><br></pre></td></tr></table></figure>

<ul>
<li><p>类适配器模式类图</p>
<p> <img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/aHR0cDovL2ltYWdlLmxhaWppYW5mZW5nLm9yZy9QYWNrYWdlJTIwY2xhc3NhZGFwdGVyLnBuZw.jpg" alt="类适配器模式类图" loading="lazy"> </p>
</li>
<li><p>这样我们即可在新接口 Target 中适配旧的接口或类</p>
</li>
</ul>
<h5 id="2-对象适配器"><a href="#2-对象适配器" class="headerlink" title="2 对象适配器"></a>2 对象适配器</h5><ul>
<li>对象适配器与类适配器不同之处在于，类适配器通过继承来完成适配，对象适配器则是通过关联来完成，这里稍微修改一下 Adapter 类即可将转变为对象适配器</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">implements</span> <span class="title">Target</span></span>&#123;</span><br><span class="line">    <span class="comment">// 适配者是对象适配器的一个属性</span></span><br><span class="line">    <span class="keyword">private</span> Adaptee adaptee = <span class="keyword">new</span> Adaptee();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        adaptee.adapteeRequest();</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>对象适配器模式类图</p>
</li>
<li><p> <img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/aHR0cDovL2ltYWdlLmxhaWppYW5mZW5nLm9yZy8yMDE4MDkxOVBhY2thZ2Vfb2JqZWN0YWRhcHRlci5wbmc.jpg" alt="对象适配器模式类图" loading="lazy"> </p>
</li>
<li><p>注意这里的 Adapter 是将 Adaptee 作为一个成员属性，而不是继承它</p>
</li>
</ul>
<h5 id="3-电压适配器"><a href="#3-电压适配器" class="headerlink" title="3 电压适配器"></a>3 电压适配器</h5><ul>
<li><p>再来一个好理解的例子，我们国家的民用电都是 220V，日本是 110V，而我们的手机充电一般需要 5V，这时候要充电，就需要一个电压适配器，将 220V 或者 100V 的输入电压变换为 5V 输出</p>
</li>
<li><p>定义输出交流电接口，输出220V交流电类和输出110V交流电类</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">outputAC</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AC110</span> <span class="keyword">implements</span> <span class="title">AC</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> output = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">outputAC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AC220</span> <span class="keyword">implements</span> <span class="title">AC</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> output = <span class="number">220</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">outputAC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>适配器接口，其中 <code>support()</code> 方法用于检查输入的电压是否与适配器匹配，<code>outputDC5V()</code> 方法则用于将输入的电压变换为 5V 后输出</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DC5Adapter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">support</span><span class="params">(AC ac)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">outputDC5V</span><span class="params">(AC ac)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>实现中国变压适配器和日本变压适配器</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChinaPowerAdapter</span> <span class="keyword">implements</span> <span class="title">DC5Adapter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> voltage = <span class="number">220</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">support</span><span class="params">(AC ac)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (voltage == ac.outputAC());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">outputDC5V</span><span class="params">(AC ac)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> adapterInput = ac.outputAC();</span><br><span class="line">        <span class="comment">//变压器...</span></span><br><span class="line">        <span class="keyword">int</span> adapterOutput = adapterInput / <span class="number">44</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用ChinaPowerAdapter变压适配器，输入AC:&quot;</span> + adapterInput + <span class="string">&quot;V&quot;</span> + <span class="string">&quot;，输出DC:&quot;</span> + adapterOutput + <span class="string">&quot;V&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> adapterOutput;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JapanPowerAdapter</span> <span class="keyword">implements</span> <span class="title">DC5Adapter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> voltage = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">support</span><span class="params">(AC ac)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (voltage == ac.outputAC());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">outputDC5V</span><span class="params">(AC ac)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> adapterInput = ac.outputAC();</span><br><span class="line">        <span class="comment">//变压器...</span></span><br><span class="line">        <span class="keyword">int</span> adapterOutput = adapterInput / <span class="number">22</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用JapanPowerAdapter变压适配器，输入AC:&quot;</span> + adapterInput + <span class="string">&quot;V&quot;</span> + <span class="string">&quot;，输出DC:&quot;</span> + adapterOutput + <span class="string">&quot;V&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> adapterOutput;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>测试，准备中国变压适配器和日本变压适配器各一个，定义一个方法可以根据电压找到合适的变压器，然后进行测试</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;DC5Adapter&gt; adapters = <span class="keyword">new</span> LinkedList&lt;DC5Adapter&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.adapters.add(<span class="keyword">new</span> ChinaPowerAdapter());</span><br><span class="line">        <span class="keyword">this</span>.adapters.add(<span class="keyword">new</span> JapanPowerAdapter());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据电压找合适的变压器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DC5Adapter <span class="title">getPowerAdapter</span><span class="params">(AC ac)</span> </span>&#123;</span><br><span class="line">        DC5Adapter adapter = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (DC5Adapter ad : <span class="keyword">this</span>.adapters) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ad.support(ac)) &#123;</span><br><span class="line">                adapter = ad;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (adapter == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span>  IllegalArgumentException(<span class="string">&quot;没有找到合适的变压适配器&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> adapter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        AC chinaAC = <span class="keyword">new</span> AC220();</span><br><span class="line">        DC5Adapter adapter = test.getPowerAdapter(chinaAC);</span><br><span class="line">        adapter.outputDC5V(chinaAC);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 去日本旅游，电压是 110V</span></span><br><span class="line">        AC japanAC = <span class="keyword">new</span> AC110();</span><br><span class="line">        adapter = test.getPowerAdapter(japanAC);</span><br><span class="line">        adapter.outputDC5V(japanAC);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>输出</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">使用ChinaPowerAdapter变压适配器，输入AC:<span class="number">220</span>V，输出DC:<span class="number">5</span>V</span><br><span class="line">使用JapanPowerAdapter变压适配器，输入AC:<span class="number">110</span>V，输出DC:<span class="number">5</span>V</span><br></pre></td></tr></table></figure>

<h4 id="4-3-适配器模式总结"><a href="#4-3-适配器模式总结" class="headerlink" title="4.3 适配器模式总结"></a>4.3 适配器模式总结</h4><h5 id="主要优点："><a href="#主要优点：" class="headerlink" title="主要优点："></a>主要优点：</h5><ol>
<li>将目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配者类，无须修改原有结构。</li>
<li>增加了类的透明性和复用性，将具体的业务实现过程封装在适配者类中，对于客户端类而言是透明的，而且提高了适配者的复用性，同一个适配者类可以在多个不同的系统中复用。</li>
<li>灵活性和扩展性都非常好，通过使用配置文件，可以很方便地更换适配器，也可以在不修改原有代码的基础上增加新的适配器类，完全符合“==开闭原则==”。</li>
</ol>
<h5 id="1-类-适配器模式还有如下-优-点："><a href="#1-类-适配器模式还有如下-优-点：" class="headerlink" title="1 ==类==适配器模式还有如下==优==点："></a>1 ==类==适配器模式还有如下==优==点：</h5><ul>
<li>由于适配器类是适配者类的子类，因此可以在适配器类中置换一些适配者的方法，使得适配器的灵活性更强。</li>
</ul>
<h5 id="2-对-象适配器模式还有如下-优-点："><a href="#2-对-象适配器模式还有如下-优-点：" class="headerlink" title="2 ==对==象适配器模式还有如下==优==点："></a>2 ==对==象适配器模式还有如下==优==点：</h5><ul>
<li>一个对象适配器可以把多个不同的适配者适配到同一个目标；</li>
<li>可以适配一个适配者的子类，由于适配器和适配者之间是关联关系，根据“==里氏代换原则==”，适配者的子类也可通过该适配器进行适配。</li>
</ul>
<h5 id="3-类-适配器模式的-缺-点如下："><a href="#3-类-适配器模式的-缺-点如下：" class="headerlink" title="3 ==类==适配器模式的==缺==点如下："></a>3 ==类==适配器模式的==缺==点如下：</h5><ul>
<li> 对于Java、C#等不支持多重类继承的语言，一次最多只能适配一个适配者类，不能同时适配多个适配者；</li>
<li>适配者类不能为最终类，如在Java中不能为final类，C#中不能为sealed类；</li>
<li>在Java、C#等语言中，类适配器模式中的目标抽象类只能为接口，不能为类，其使用有一定的局限性。</li>
</ul>
<h5 id="4-对象-适配器模式的-缺-点如下："><a href="#4-对象-适配器模式的-缺-点如下：" class="headerlink" title="4 ==对象==适配器模式的==缺==点如下："></a>4 ==对象==适配器模式的==缺==点如下：</h5><ul>
<li>与类适配器模式相比，要在适配器中置换适配者类的某些方法比较麻烦。</li>
<li>如果一定要置换掉适配者类的一个或多个方法，可以先做一个适配者类的子类，将适配者类的方法置换掉，然后再把适配者类的子类当做真正的适配者进行适配，实现过程较为复杂。</li>
</ul>
<h5 id="适用场景："><a href="#适用场景：" class="headerlink" title="适用场景："></a>适用场景：</h5><ul>
<li>系统需要使用一些现有的类，而这些类的接口（如方法名）不符合系统的需要，甚至没有这些类的源代码。</li>
<li>想创建一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作。</li>
</ul>
<h4 id="4-4-源码分析适配器模式的典型应用"><a href="#4-4-源码分析适配器模式的典型应用" class="headerlink" title="4.4 源码分析适配器模式的典型应用"></a>4.4 源码分析适配器模式的典型应用</h4><h5 id="1-spring-AOP中的适配器模式"><a href="#1-spring-AOP中的适配器模式" class="headerlink" title="1 spring AOP中的适配器模式"></a>1 spring AOP中的适配器模式</h5><ul>
<li><p>在Spring的Aop中，使用的 <code>Advice（通知）</code> 来增强被代理类的功能。</p>
</li>
<li><p><code>Advice</code>的类型有：MethodBeforeAdvice、AfterReturningAdvice、ThrowsAdvice</p>
</li>
<li><p>在每个类型 <code>Advice</code> 都有对应的拦截器，MethodBeforeAdviceInterceptor、AfterReturningAdviceInterceptor、ThrowsAdviceInterceptor</p>
</li>
<li><p>Spring需要将每个 <code>Advice</code> <strong>都封装成对应的拦截器类型</strong>，返回给容器，所以需要使用适配器模式对 <code>Advice</code> 进行转换</p>
</li>
<li><p>三个适配者类 Adaptee 如下：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MethodBeforeAdvice</span> <span class="keyword">extends</span> <span class="title">BeforeAdvice</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">before</span><span class="params">(Method var1, Object[] var2, <span class="meta">@Nullable</span> Object var3)</span> <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AfterReturningAdvice</span> <span class="keyword">extends</span> <span class="title">AfterAdvice</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">afterReturning</span><span class="params">(<span class="meta">@Nullable</span> Object var1, Method var2, Object[] var3, <span class="meta">@Nullable</span> Object var4)</span> <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ThrowsAdvice</span> <span class="keyword">extends</span> <span class="title">AfterAdvice</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>目标接口 Target，有两个方法，一个判断 Advice 类型是否匹配，一个是工厂方法，创建对应类型的 Advice 对应的拦截器</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AdvisorAdapter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">supportsAdvice</span><span class="params">(Advice var1)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">MethodInterceptor <span class="title">getInterceptor</span><span class="params">(Advisor var1)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>三个适配器类 Adapter 分别如下，注意其中的 Advice、Adapter、Interceptor之间的对应关系</p>
<p>  class MethodBeforeAdviceAdapter implements AdvisorAdapter, Serializable {</p>
<pre><code>  @Override
  public boolean supportsAdvice(Advice advice) &#123;
      return (advice instanceof MethodBeforeAdvice);
  &#125;

  @Override
  public MethodInterceptor getInterceptor(Advisor advisor) &#123;
      MethodBeforeAdvice advice = (MethodBeforeAdvice) advisor.getAdvice();
      return new MethodBeforeAdviceInterceptor(advice);
  &#125;
</code></pre>
<p>  }</p>
<p>  @SuppressWarnings(“serial”)<br>  class AfterReturningAdviceAdapter implements AdvisorAdapter, Serializable {</p>
<pre><code>  @Override
  public boolean supportsAdvice(Advice advice) &#123;
      return (advice instanceof AfterReturningAdvice);
  &#125;
  @Override
  public MethodInterceptor getInterceptor(Advisor advisor) &#123;
      AfterReturningAdvice advice = (AfterReturningAdvice) advisor.getAdvice();
      return new AfterReturningAdviceInterceptor(advice);
  &#125;
</code></pre>
<p>  }</p>
<p>  class ThrowsAdviceAdapter implements AdvisorAdapter, Serializable {</p>
<pre><code>  @Override
  public boolean supportsAdvice(Advice advice) &#123;
      return (advice instanceof ThrowsAdvice);
  &#125;
  @Override
  public MethodInterceptor getInterceptor(Advisor advisor) &#123;
      return new ThrowsAdviceInterceptor(advisor.getAdvice());
  &#125;
</code></pre>
<p>  }</p>
</li>
<li><p>客户端 DefaultAdvisorAdapterRegistry</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultAdvisorAdapterRegistry</span> <span class="keyword">implements</span> <span class="title">AdvisorAdapterRegistry</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;AdvisorAdapter&gt; adapters = <span class="keyword">new</span> ArrayList(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultAdvisorAdapterRegistry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这里注册了适配器</span></span><br><span class="line">        <span class="keyword">this</span>.registerAdvisorAdapter(<span class="keyword">new</span> MethodBeforeAdviceAdapter());</span><br><span class="line">        <span class="keyword">this</span>.registerAdvisorAdapter(<span class="keyword">new</span> AfterReturningAdviceAdapter());</span><br><span class="line">        <span class="keyword">this</span>.registerAdvisorAdapter(<span class="keyword">new</span> ThrowsAdviceAdapter());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> MethodInterceptor[] getInterceptors(Advisor advisor) <span class="keyword">throws</span> UnknownAdviceTypeException &#123;</span><br><span class="line">        List&lt;MethodInterceptor&gt; interceptors = <span class="keyword">new</span> ArrayList(<span class="number">3</span>);</span><br><span class="line">        Advice advice = advisor.getAdvice();</span><br><span class="line">        <span class="keyword">if</span> (advice <span class="keyword">instanceof</span> MethodInterceptor) &#123;</span><br><span class="line">            interceptors.add((MethodInterceptor)advice);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Iterator var4 = <span class="keyword">this</span>.adapters.iterator();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(var4.hasNext()) &#123;</span><br><span class="line">            AdvisorAdapter adapter = (AdvisorAdapter)var4.next();</span><br><span class="line">            <span class="keyword">if</span> (adapter.supportsAdvice(advice)) &#123;   <span class="comment">// 这里调用适配器方法</span></span><br><span class="line">                interceptors.add(adapter.getInterceptor(advisor));  <span class="comment">// 这里调用适配器方法</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (interceptors.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnknownAdviceTypeException(advisor.getAdvice());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (MethodInterceptor[])interceptors.toArray(<span class="keyword">new</span> MethodInterceptor[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...省略...</span></span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
<ul>
<li><p>这里看 while 循环里，逐个取出注册的适配器，调用 supportsAdvice() 方法来判断 Advice 对应的类型，然后调用 getInterceptor() 创建对应类型的拦截器</p>
</li>
<li><p>spring aop 适配器模式</p>
<p> <img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/aHR0cDovL2ltYWdlLmxhaWppYW5mZW5nLm9yZy8yMDE4MDkxOV8yMjE3LmpwZw.jpg" alt="spring aop 适配器模式" loading="lazy"> </p>
</li>
<li><p>这里应该属于对象适配器模式，关键字 instanceof 可看成是 Advice 的方法，不过这里的 Advice 对象是从外部传进来，而不是成员属性</p>
</li>
</ul>
<h5 id="2-spring-JPA中的适配器模式"><a href="#2-spring-JPA中的适配器模式" class="headerlink" title="2 spring JPA中的适配器模式"></a>2 spring JPA中的适配器模式</h5><ul>
<li><p>在Spring的ORM包中，对于JPA的支持也是采用了适配器模式，首先定义了一个接口的 JpaVendorAdapter，然后不同的持久层框架都实现此接口。</p>
</li>
<li><p>jpaVendorAdapter：用于设置实现厂商JPA实现的特定属性，如设置Hibernate的是否自动生成DDL的属性generateDdl；这些属性是厂商特定的，因此最好在这里设置；目前Spring提供 HibernateJpaVendorAdapter、OpenJpaVendorAdapter、EclipseLinkJpaVendorAdapter、TopLinkJpaVendorAdapter 四个实现。其中最重要的属性是 database，用来指定使用的数据库类型，从而能根据数据库类型来决定比如如何将数据库特定异常转换为Spring的一致性异常，目前支持如下数据库（DB2、DERBY、H2、HSQL、INFORMIX、MYSQL、ORACLE、POSTGRESQL、SQL_SERVER、SYBASE）</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">JpaVendorAdapter</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="comment">// 返回一个具体的持久层提供者</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> PersistenceProvider <span class="title">getPersistenceProvider</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回持久层提供者的包名</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getPersistenceProviderRootPackage</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回持久层提供者的属性</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> Map&lt;String, ?&gt; getJpaPropertyMap();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回JpaDialect</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> JpaDialect <span class="title">getJpaDialect</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回持久层管理器工厂</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> Class&lt;? extends EntityManagerFactory&gt; getEntityManagerFactoryInterface();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回持久层管理器</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> Class&lt;? extends EntityManager&gt; getEntityManagerInterface();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 自定义回调方法</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">postProcessEntityManagerFactory</span><span class="params">(EntityManagerFactory paramEntityManagerFactory)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>我们来看其中一个适配器实现类 HibernateJpaVendorAdapter</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HibernateJpaVendorAdapter</span> <span class="keyword">extends</span> <span class="title">AbstractJpaVendorAdapter</span> </span>&#123;</span><br><span class="line">    <span class="comment">//设定持久层提供者</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PersistenceProvider persistenceProvider;</span><br><span class="line">    <span class="comment">//设定持久层方言</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> JpaDialect jpaDialect;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HibernateJpaVendorAdapter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.persistenceProvider = <span class="keyword">new</span> HibernatePersistence();</span><br><span class="line">        <span class="keyword">this</span>.jpaDialect = <span class="keyword">new</span> HibernateJpaDialect();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回持久层方言</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PersistenceProvider <span class="title">getPersistenceProvider</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.persistenceProvider;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回持久层提供者</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPersistenceProviderRootPackage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;org.hibernate&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回JPA的属性</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">getJpaPropertyMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map jpaProperties = <span class="keyword">new</span> HashMap();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (getDatabasePlatform() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            jpaProperties.put(<span class="string">&quot;hibernate.dialect&quot;</span>, getDatabasePlatform());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (getDatabase() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Class databaseDialectClass = determineDatabaseDialectClass(getDatabase());</span><br><span class="line">            <span class="keyword">if</span> (databaseDialectClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">                jpaProperties.put(<span class="string">&quot;hibernate.dialect&quot;</span>,</span><br><span class="line">                        databaseDialectClass.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isGenerateDdl()) &#123;</span><br><span class="line">            jpaProperties.put(<span class="string">&quot;hibernate.hbm2ddl.auto&quot;</span>, <span class="string">&quot;update&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isShowSql()) &#123;</span><br><span class="line">            jpaProperties.put(<span class="string">&quot;hibernate.show_sql&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> jpaProperties;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设定数据库</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Class <span class="title">determineDatabaseDialectClass</span><span class="params">(Database database)</span>     </span></span><br><span class="line"><span class="function">    </span>&#123;                                                                                       </span><br><span class="line">        <span class="keyword">switch</span> (<span class="number">1.</span>$SwitchMap$org$springframework$orm$jpa$vendor$Database[database.ordinal()]) </span><br><span class="line">        &#123;                                                                                     </span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:                                                                             </span><br><span class="line">          <span class="keyword">return</span> DB2Dialect.class;                                                            </span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:                                                                               </span><br><span class="line">          <span class="keyword">return</span> DerbyDialect.class;                                                          </span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:                                                                               </span><br><span class="line">          <span class="keyword">return</span> H2Dialect.class;                                                             </span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:                                                                               </span><br><span class="line">          <span class="keyword">return</span> HSQLDialect.class;                                                           </span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:                                                                               </span><br><span class="line">          <span class="keyword">return</span> InformixDialect.class;                                                       </span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:                                                                               </span><br><span class="line">          <span class="keyword">return</span> MySQLDialect.class;                                                          </span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>:                                                                               </span><br><span class="line">          <span class="keyword">return</span> Oracle9iDialect.class;                                                       </span><br><span class="line">        <span class="keyword">case</span> <span class="number">8</span>:                                                                               </span><br><span class="line">          <span class="keyword">return</span> PostgreSQLDialect.class;                                                     </span><br><span class="line">        <span class="keyword">case</span> <span class="number">9</span>:                                                                               </span><br><span class="line">          <span class="keyword">return</span> SQLServerDialect.class;                                                      </span><br><span class="line">        <span class="keyword">case</span> <span class="number">10</span>:                                                                              </span><br><span class="line">          <span class="keyword">return</span> SybaseDialect.class; &#125;                                                       </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;              </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回JPA方言</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JpaDialect <span class="title">getJpaDialect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.jpaDialect;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回JPA实体管理器工厂</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;? extends EntityManagerFactory&gt; getEntityManagerFactoryInterface() &#123;</span><br><span class="line">        <span class="keyword">return</span> HibernateEntityManagerFactory.class;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回JPA实体管理器</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;? extends EntityManager&gt; getEntityManagerInterface() &#123;</span><br><span class="line">        <span class="keyword">return</span> HibernateEntityManager.class;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>配置文件中可以这样指定</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jpaVendorAdapter&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter&quot;</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;generateDdl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span> /&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;database&quot;</span> <span class="attr">value</span>=<span class="string">&quot;HSQL&quot;</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jpaDialect&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.orm.jpa.vendor.HibernateJpaDialect&quot;</span>/&gt;</span> </span><br></pre></td></tr></table></figure>

<h5 id="3-spring-MVC中的适配器模式"><a href="#3-spring-MVC中的适配器模式" class="headerlink" title="3 spring MVC中的适配器模式"></a>3 spring MVC中的适配器模式</h5><ul>
<li><p>Spring MVC中的适配器模式主要用于执行目标 Controller 中的请求处理方法。</p>
</li>
<li><p>在Spring MVC中，DispatcherServlet 作为用户，HandlerAdapter 作为期望接口，具体的适配器实现类用于对目标类进行适配，Controller 作为需要适配的类。</p>
</li>
<li><p>为什么要在 Spring MVC 中使用适配器模式？Spring MVC 中的 Controller 种类众多，不同类型的 Controller 通过不同的方法来对请求进行处理。如果不利用适配器模式的话，DispatcherServlet 直接获取对应类型的 Controller，需要的自行来判断，像下面这段代码一样：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(mappedHandler.getHandler() <span class="keyword">instanceof</span> MultiActionController)&#123;  </span><br><span class="line">   ((MultiActionController)mappedHandler.getHandler()).xxx  </span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(mappedHandler.getHandler() <span class="keyword">instanceof</span> XXX)&#123;  </span><br><span class="line">    ...  </span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(...)&#123;  </span><br><span class="line">   ...  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<ul>
<li><p>这样假设如果我们增加一个 HardController,就要在代码中加入一行 if(mappedHandler.getHandler() instanceof HardController)，这种形式就使得程序难以维护，也违反了设计模式中的开闭原则 – 对扩展开放，对修改关闭。</p>
</li>
<li><p>我们来看看源码，首先是适配器接口 HandlerAdapter</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Object var1)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">ModelAndView <span class="title">handle</span><span class="params">(HttpServletRequest var1, HttpServletResponse var2, Object var3)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">getLastModified</span><span class="params">(HttpServletRequest var1, Object var2)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>现该接口的适配器每一个 Controller 都有一个适配器与之对应，这样的话，每自定义一个 Controller 需要定义一个实现 HandlerAdapter 的适配器。</p>
</li>
<li><p>springmvc 中提供的 Controller 实现类有如下</p>
</li>
</ul>
<p> <img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/aHR0cDovL2ltYWdlLmxhaWppYW5mZW5nLm9yZy8yMDE4MDkxOV8yMzMzMjcucG5n.jpg" alt="spring mvc Controller 提供的实现类" loading="lazy"> </p>
<ul>
<li>springmvc 中提供的 HandlerAdapter 实现类如下</li>
</ul>
<p> <img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/aHR0cDovL2ltYWdlLmxhaWppYW5mZW5nLm9yZy8yMDE4MDkxOV8yMzQzMjUucG5n.jpg" alt="spring mvc HandlerAdapter 提供的实现类" loading="lazy"> </p>
<ul>
<li>HttpRequestHandlerAdapter 这个适配器代码如下</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpRequestHandlerAdapter</span> <span class="keyword">implements</span> <span class="title">HandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HttpRequestHandlerAdapter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Object handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> handler <span class="keyword">instanceof</span> HttpRequestHandler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ((HttpRequestHandler)handler).handleRequest(request, response);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getLastModified</span><span class="params">(HttpServletRequest request, Object handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> handler <span class="keyword">instanceof</span> LastModified ? ((LastModified)handler).getLastModified(request) : -<span class="number">1L</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>当Spring容器启动后，会将所有定义好的适配器对象存放在一个List集合中，当一个请求来临时，DispatcherServlet 会通过 handler 的类型找到对应适配器，并将该适配器对象返回给用户，然后就可以统一通过适配器的 hanle() 方法来调用 Controller 中的用于处理请求的方法。 </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DispatcherServlet</span> <span class="keyword">extends</span> <span class="title">FrameworkServlet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;HandlerAdapter&gt; handlerAdapters;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//初始化handlerAdapters</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initHandlerAdapters</span><span class="params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//..省略...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历所有的 HandlerAdapters，通过 supports 判断找到匹配的适配器</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> HandlerAdapter <span class="title">getHandlerAdapter</span><span class="params">(Object handler)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (HandlerAdapter ha : <span class="keyword">this</span>.handlerAdapters) &#123;</span><br><span class="line">			<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">				logger.trace(<span class="string">&quot;Testing handler adapter [&quot;</span> + ha + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (ha.supports(handler)) &#123;</span><br><span class="line">				<span class="keyword">return</span> ha;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 分发请求，请求需要找到匹配的适配器来处理</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		HttpServletRequest processedRequest = request;</span><br><span class="line">		HandlerExecutionChain mappedHandler = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Determine handler for the current request.</span></span><br><span class="line">		mappedHandler = getHandler(processedRequest);</span><br><span class="line">			</span><br><span class="line">		<span class="comment">// 确定当前请求的匹配的适配器.</span></span><br><span class="line">		HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">		ha.getLastModified(request, mappedHandler.getHandler());</span><br><span class="line">					</span><br><span class="line">		mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// ...省略...</span></span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>
<ul>
<li>通过适配器模式我们将所有的 controller 统一交给 HandlerAdapter 处理，免去了写大量的 if-else 语句对 Controller 进行判断，也更利于扩展新的 Controller 类型。</li>
</ul>
<h3 id="5-原型模式"><a href="#5-原型模式" class="headerlink" title="5 原型模式"></a>5 原型模式</h3><ul>
<li>复制粘贴功能我们都用过，我们可以把一个文件从一个地方复制到另外一个地方，复制完成之后这个文件和之前的文件也没有一点差别，这就是原型模式的思想：首先创建一个实例，然后通过这个实例去拷贝创建新的实例。这篇文章就好好地分析一下原型模式。</li>
</ul>
<h4 id="5-1-认识原型模式"><a href="#5-1-认识原型模式" class="headerlink" title="5.1 认识原型模式"></a>5.1 认识原型模式</h4><h5 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h5><ul>
<li><p>用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象。</p>
</li>
<li><p>我们拿电脑中复制粘贴的例子来演示一下原型模式.</p>
</li>
</ul>
<p><img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/adaf2edda3cc7cd972d6e7f14b0b033ab80e912b.jpeg" alt="img" loading="lazy"></p>
<ul>
<li>上面这张图已经很明显了，首先我们需要一个文件，这个文件一定要有可以被克隆的功能，那么我们创建这个文件之后，就可以通过它克隆出无数个。</li>
</ul>
<h5 id="2、java类图分析"><a href="#2、java类图分析" class="headerlink" title="2、java类图分析"></a>2、java类图分析</h5><ul>
<li>下面我们再从类图的角度来分析一下：</li>
</ul>
<p><img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/86d6277f9e2f0708be71f1359b2e9a9ca901f29b.jpeg" alt="img" loading="lazy"></p>
<ul>
<li><p>首先我们可以看到一共有三个角色：</p>
<ol>
<li>客户(Client)角色：客户类提出创建对象的请求；也就是我们用户使用复制粘贴的功能。</li>
<li>抽象原型(Prototype)角色：此角色定义了的具体原型类所需的实现的方法。也就是定义一个文件，说明一下它有被克隆复制的功能。</li>
<li>具体原型(Concrete Prototype)角色：实现抽象原型角色的克隆接口。就是我们的文件实现了可以被复制的功能。</li>
</ol>
</li>
<li><p>我们会发现其实原型模式的核心就是Prototype（抽象原型），他需要继承Cloneable接口，并且重写Object类中的clone方法才能有复制粘贴的功能。</p>
</li>
</ul>
<h5 id="3、分类"><a href="#3、分类" class="headerlink" title="3、分类"></a>3、分类</h5><ul>
<li>既然我们知道原型模式的核心就是拷贝对象，那么我们能拷贝一个对象实例的什么内容呢？这就要区分深拷贝和浅拷贝之分了。</li>
</ul>
<ol>
<li>浅拷贝：我们只拷贝对象中的基本数据类型（8种），对于数组、容器、引用对象等都不会拷贝</li>
<li>深拷贝：不仅能拷贝基本数据类型，还能拷贝那些数组、容器、引用对象等，</li>
</ol>
<ul>
<li>下面我们就使用代码去实现一下原型模式。这里实现的是不仅有基本数据类型，还有数组和容器，所以实现的是深拷贝。</li>
</ul>
<h4 id="5-2-代码实现原型模式"><a href="#5-2-代码实现原型模式" class="headerlink" title="5.2 代码实现原型模式"></a>5.2 代码实现原型模式</h4><h5 id="第一步：定义抽象原型"><a href="#第一步：定义抽象原型" class="headerlink" title="第一步：定义抽象原型"></a>第一步：定义抽象原型</h5><p><img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/96dda144ad3459822698967f7efe13a8caef84d8.jpeg" alt="img" loading="lazy"></p>
<h5 id="第二步：定义具体原型"><a href="#第二步：定义具体原型" class="headerlink" title="第二步：定义具体原型"></a>第二步：定义具体原型</h5><p><img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/4afbfbedab64034f3933ea28dac95b340a551d34.jpeg" alt="img" loading="lazy"></p>
<h5 id="第三步：定义用户去模拟过程"><a href="#第三步：定义用户去模拟过程" class="headerlink" title="第三步：定义用户去模拟过程"></a>第三步：定义用户去模拟过程</h5><p><img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/03087bf40ad162d941398a0662d58be98b13cde1.jpeg" alt="img" loading="lazy"></p>
<ul>
<li>我们可以看到，克隆出来的两个文件和之前的文件是一样的，而且我们实现了深拷贝，对于数组、引用等对象同样的适用。</li>
</ul>
<h4 id="5-3-分析原型模式"><a href="#5-3-分析原型模式" class="headerlink" title="5.3 分析原型模式"></a>5.3 分析原型模式</h4><ul>
<li><p>对于原型模式有几个问题需要我们去注意一下</p>
<ol>
<li><h5 id="克隆对象不会调用构造方法"><a href="#克隆对象不会调用构造方法" class="headerlink" title="克隆对象不会调用构造方法"></a>克隆对象不会调用构造方法</h5><ul>
<li>从上面的输出其实我们也可以发现，构造方法只在一开始我们创建原型的时候输出了，fileB和fileC都没有调用构造方法，</li>
<li>这是因为执行clone方法的时候是直接从内存中去获取数据的，在第一次创建对象的时候就会把数据在内存保留一份，克隆的时候直接调用就好了</li>
</ul>
</li>
<li><h5 id="访问权限对原型模式无效"><a href="#访问权限对原型模式无效" class="headerlink" title="访问权限对原型模式无效"></a>访问权限对原型模式无效</h5><ul>
<li>原理也很简单，我们是从内存中直接复制的，所以克隆起来也会直接无视，复制相应的内容就好了。</li>
</ul>
</li>
<li><h5 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h5><ol>
<li>当我们的类初始化需要消耗很多的资源时，就可以使用原型模式，因为我们的克隆不会执行构造方法，避免了初始化占有的时间和空间。</li>
<li>一个对象被其她对象访问，并且能够修改时，访问权限都无效了，什么都能修改。</li>
</ol>
</li>
</ol>
</li>
<li><p>OK，对于设计模式其实主要是理解其思想，然后根据自己的需求去灵活的使用。对于其他设计模式的相关文章也在持续更新当中。</p>
</li>
</ul>
<h3 id="6-建造者模式"><a href="#6-建造者模式" class="headerlink" title="6 建造者模式"></a>6 建造者模式</h3><h4 id="6-0-建造者模式"><a href="#6-0-建造者模式" class="headerlink" title="6.0.建造者模式"></a>6.0.建造者模式</h4><ul>
<li><p>建造者模式也属于==创建型==模式， 它提供了一种创建对象的==最佳方式==。</p>
</li>
<li><p>==<strong>定义</strong>==:将一个 <strong>复杂对象</strong> 的==构建==与它的==表示==分离，使得<strong>同样的构建过程可以创建不同的表示</strong> </p>
</li>
<li><p>==<strong>主要作用</strong>==: 在用户不知道<code>对象的建造过程和细节</code>的情况下就可以直接创建复杂的对象。</p>
</li>
<li><p><strong>用户</strong> 只需要给出指定复杂对象的==类型和内容==， <strong>建造者模式</strong> 负责==按顺序创建==复杂对象(<strong>把内部的建造过程和细节隐藏起来</strong>)</p>
</li>
<li><p>==<strong>例子</strong>==:</p>
<ul>
<li>工厂(建造者模式) :负责制造汽车(组装过程和细节在工厂内)<ul>
<li>设计模式结合过程：<strong>工厂模式生产零件—》建造者模式创建复杂对象—》再去使用</strong> </li>
</ul>
</li>
<li>汽车购买者(用户) :你只需要说出你需要的型号(对象的类型和内容)，然后直接购买就可以使用<br>了(不需要知道汽车是怎么组装的(车轮、车门、发动机、方向盘等等) )</li>
</ul>
</li>
<li><p>==<strong>角色分析</strong>==：</p>
<img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/1584956106705.png" alt="1584956106705" style="zoom: 80%;float:left" / loading="lazy"></li>
<li><p>既然是建造者模式，那么我们还是继续造房吧，其实我也想不到更简单的例子。</p>
<ul>
<li>假设造房简化为如下步骤:<br>(1)地基(2)钢筋工程(3)铺电线(4) 粉刷;   </li>
<li>“如果”要盖一座房子，首先要找一 个建筑公司或工程承包商(指挥者)。</li>
<li>承包商指挥工人(具体建造者)过来造房子(产品) , 最后验收。</li>
</ul>
</li>
<li><p>上面示例是 Builder模式的常规用法,导演类Director在Builder模式中具有很重要的作用，</p>
<ul>
<li>它用于==指导==具体构建者如何构建产品，==控制调用==先后次序，并向调用者返回完整的产品类,</li>
<li>但是有些情况下需要简化系统结构，可以把Director和抽象建造者进行结合。</li>
</ul>
</li>
<li><p>通过静态内部类方式实现零件无序装配构造,这种方式使用更加灵活，更符合定义。</p>
<ul>
<li>内部有复杂对象的默认实现，使用时可以根据用户需求自由定义更改内容，并且无需改变具体的构造方式。就可以生产出不同复杂产品</li>
</ul>
</li>
<li><p>比如:</p>
<ul>
<li>比如麦当劳的套餐,服务员(具体建造者)可以随意搭配任意几种产品(零件)组成一款套餐(产品)，然后出售给客户。</li>
<li>比第一种方式少了指挥者，主要是因为第种方式把指挥者交给用户来操作， 使得产品的创建更加简单灵活。</li>
</ul>
</li>
</ul>
<hr>
<p><strong>背景</strong></p>
<blockquote>
<p>当一个类的内部数据过于复杂的时候（通常是负责持有数据的类，比如Config、VO、PO、Entity…），要创建的话可能就需要了解这个类的内部结构，还有这些东西是怎么组织装配等一大坨乱七八糟的东西，这个时候就会增加学习成本而且会很混乱，这个时候就想啊想一种什么法子来管理一下这个类中的数据呢，怎么在创建的时候让它按部就班的来，并且代码可读性很好别让我看花了眼啊，我要的东西也能都很好设置进来，这就是Builder模式的应用场景，Builder模式可以将一个类的构建和表示进行分离。</p>
</blockquote>
<h4 id="6-1-介绍"><a href="#6-1-介绍" class="headerlink" title="6.1.介绍"></a>6.1.介绍</h4><h5 id="1-1什么是构建者模式"><a href="#1-1什么是构建者模式" class="headerlink" title="1.1什么是构建者模式"></a>1.1什么是构建者模式</h5><blockquote>
<p>创建者模式又叫建造者模式，是将一个复杂的对象的<strong>构建</strong>与它的<strong>表示</strong>分离，使<br> 得同样的构建过程可以创建不同的表示。创建者模式隐藏了复杂对象的创建过程，它把复杂对象的创建过程加以抽象，通过子类继承或者重载的方式，动态的创建具有复合属性的对象。</p>
</blockquote>
<h5 id="1-2适用场景："><a href="#1-2适用场景：" class="headerlink" title="1.2适用场景："></a>1.2适用场景：</h5><ul>
<li>隔离复杂对象的创建和使用，相同的方法，不同执行顺序，产生不同事件结果</li>
<li>多个部件都可以装配到一个对象中，但产生的运行结果不相同</li>
<li>产品类非常复杂或者产品类因为调用顺序不同而产生不同作用</li>
<li>初始化一个对象时，参数过多，或者很多参数具有默认值</li>
<li>Builder模式不适合创建差异性很大的产品类<ul>
<li>产品内部变化复杂，会导致需要定义很多具体建造者类实现变化，增加项目中类的数量，增加系统的理解难度和运行成本</li>
</ul>
</li>
<li>需要生成的产品对象有复杂的内部结构，这些产品对象具备共性；</li>
</ul>
<h5 id="1-3-主要作用"><a href="#1-3-主要作用" class="headerlink" title="1.3 主要作用"></a>1.3 主要作用</h5><blockquote>
<p>在用户不知道对象的建造过程和细节的情况下就可以直接创建复杂的对象。</p>
</blockquote>
<ul>
<li>用户只需要给出指定复杂对象的类型和内容；</li>
<li>建造者模式负责按顺序创建复杂对象（把内部的建造过程和细节隐藏起来)</li>
</ul>
<h5 id="1-4-解决的问题"><a href="#1-4-解决的问题" class="headerlink" title="1.4 解决的问题"></a>1.4 解决的问题</h5><ul>
<li>方便用户创建复杂的对象（不需要知道实现过程）</li>
<li>代码复用性 &amp; 封装性（将对象构建过程和细节进行封装 &amp; 复用）</li>
</ul>
<blockquote>
<p>例子：造汽车 &amp; 买汽车。</p>
<ol>
<li><p>工厂（建造者模式）：负责制造汽车（组装过&gt;程和细节在工厂内）</p>
</li>
<li><p>汽车购买者（用户）：你只需要说出你需要的&gt;型号（对象的类型和内容），然后直接购买就可&gt;&gt;以使用了</p>
<p>（不需要知道汽车是怎么组装的（车轮、车门、&gt;发动机、方向盘等等））</p>
</li>
</ol>
</blockquote>
<h4 id="6-2-模式原理"><a href="#6-2-模式原理" class="headerlink" title="6.2. 模式原理"></a>6.2. 模式原理</h4><h5 id="2-1-UML类图-amp-组成"><a href="#2-1-UML类图-amp-组成" class="headerlink" title="2.1 UML类图 &amp; 组成"></a>2.1 UML类图 &amp; 组成</h5><p><img src="https://upload-images.jianshu.io/upload_images/2025309-b87a0396c5193070.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/860" alt="img" loading="lazy"></p>
<h5 id="2-2模式讲解："><a href="#2-2模式讲解：" class="headerlink" title="2.2模式讲解："></a>2.2模式讲解：</h5><ul>
<li>指挥者（Director）直接和客户（Client）进行需求沟通；</li>
<li>沟通后指挥者将客户创建产品的需求划分为各个部件的建造请求（Builder）；</li>
<li>将各个部件的建造请求委派到具体的建造者（ConcreteBuilder）；</li>
<li>各个具体建造者负责进行产品部件的构建；</li>
<li>最终构建成具体产品（Product）。</li>
</ul>
<h4 id="6-3-用-builder-模式创建共享单车为例子："><a href="#6-3-用-builder-模式创建共享单车为例子：" class="headerlink" title="6.3.用 builder 模式创建共享单车为例子："></a>6.3.用 builder 模式创建共享单车为例子：</h4><h5 id="1-产品类："><a href="#1-产品类：" class="headerlink" title="1 产品类："></a>1 产品类：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bike</span> </span>&#123; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> IFrame frame; </span><br><span class="line">    <span class="keyword">private</span> ISeat seat; </span><br><span class="line">    <span class="keyword">private</span> ITire tire; </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> IFrame <span class="title">getFrame</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> frame; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFrame</span><span class="params">(IFrame frame)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.frame = frame; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> ISeat <span class="title">getSeat</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> seat; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSeat</span><span class="params">(ISeat seat)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.seat = seat; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> ITire <span class="title">getTire</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> tire; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTire</span><span class="params">(ITire tire)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.tire = tire; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h5 id="2-Builder-类："><a href="#2-Builder-类：" class="headerlink" title="2  Builder 类："></a>2  Builder 类：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象 builder 类 </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildFrame</span><span class="params">()</span></span>; </span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildSeat</span><span class="params">()</span></span>; </span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildTire</span><span class="params">()</span></span>; </span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> Bike <span class="title">createBike</span><span class="params">()</span></span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h5 id="3-ConcreteBuilder-类"><a href="#3-ConcreteBuilder-类" class="headerlink" title="3 ConcreteBuilder 类 :"></a>3 ConcreteBuilder 类 :</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 具体 builder 类 </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MobikeBuilder</span> <span class="keyword">extends</span> <span class="title">Builder</span></span>&#123; </span><br><span class="line">    <span class="keyword">private</span> Bike mBike = <span class="keyword">new</span> Bike(); </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buildFrame</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        mBike.setFrame(<span class="keyword">new</span> AlloyFrame()); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buildSeat</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        mBike.setSeat(<span class="keyword">new</span> DermisSeat()); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buildTire</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        mBike.setTire(<span class="keyword">new</span> SolidTire()); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function">Bike <span class="title">createBike</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> mBike; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OfoBuilder</span> <span class="keyword">extends</span> <span class="title">Builder</span></span>&#123; </span><br><span class="line">    <span class="keyword">private</span> Bike mBike = <span class="keyword">new</span> Bike(); </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buildFrame</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        mBike.setFrame(<span class="keyword">new</span> CarbonFrame()); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buildSeat</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        mBike.setSeat(<span class="keyword">new</span> RubberSeat()); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buildTire</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        mBike.setTire(<span class="keyword">new</span> InflateTire()); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function">Bike <span class="title">createBike</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> mBike; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h5 id="4-指挥者类："><a href="#4-指挥者类：" class="headerlink" title="4  指挥者类："></a>4  指挥者类：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Director</span> </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> Builder mBuilder = <span class="keyword">null</span>; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Director</span><span class="params">(Builder builder)</span> </span>&#123; </span><br><span class="line">        mBuilder = builder; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Bike <span class="title">construct</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        mBuilder.buildFrame(); </span><br><span class="line">        mBuilder.buildSeat(); </span><br><span class="line">        mBuilder.buildTire(); </span><br><span class="line">        <span class="keyword">return</span> mBuilder.createBike(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-客户端使用："><a href="#5-客户端使用：" class="headerlink" title="5  客户端使用："></a>5  客户端使用：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Click</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">        showBike(<span class="keyword">new</span> OfoBuilder()); </span><br><span class="line">        showBike(<span class="keyword">new</span> MobikeBuilder()); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">showBike</span><span class="params">(Builder builder)</span> </span>&#123;</span><br><span class="line">        Director director = <span class="keyword">new</span> Director(builder); </span><br><span class="line">        Bike bike = director.construct(); </span><br><span class="line">        bike.getFrame().frame(); </span><br><span class="line">        bike.getSeat().seat(); </span><br><span class="line">        bike.getTire().tire(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面示例是 Builder模式的常规用法，导演类 Director 在 Builder模式中具有很重要的作用，它用于指导具体构建者如何构建产品，控制调用先后次序，并向调用者返回完整的产品类，但是有些情况下需要简化系统结构，可以把Director和抽象建造者进行结合，示例代码：</p>
</blockquote>
<h5 id="6-改造后的抽象建造者："><a href="#6-改造后的抽象建造者：" class="headerlink" title="6  改造后的抽象建造者："></a>6  改造后的抽象建造者：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">NewBuilder</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildFrame</span><span class="params">()</span></span>; </span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildSeat</span><span class="params">()</span></span>; </span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildTire</span><span class="params">()</span></span>; </span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> Bike <span class="title">createBike</span><span class="params">()</span></span>; </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">    * 把导演类中的construct()方法合并到抽象建造者类中 </span></span><br><span class="line"><span class="comment">    * </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 具体产品对象 </span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Bike <span class="title">construct</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.buildFrame(); </span><br><span class="line">        <span class="keyword">this</span>.buildSeat(); </span><br><span class="line">        <span class="keyword">this</span>.buildTire(); </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.createBike(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<blockquote>
<p>这样做确实简化了系统结构，但同时也加重了抽象建造者类的职责，也不是太符合单一职责原则，如果construct() 过于复杂，建议还是封装到 Director 中<br> 除了上面的用途外，还有另外一个常用的使用方式，就是当一个类构造器需要传入很多参数时，如果创建这个类的实例，代码可读性会非常差，而且很容易引入错误，此时就可以利用 builder模式进行重构，重构前示例代码：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 省略 getter 和 setter 方法 </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span> </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> String cpu; </span><br><span class="line">    <span class="keyword">private</span> String screen; </span><br><span class="line">    <span class="keyword">private</span> String memory; </span><br><span class="line">    <span class="keyword">private</span> String mainboard; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Computer</span><span class="params">(String cpu, String screen, String memory, String mainboard)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.cpu = cpu; </span><br><span class="line">        <span class="keyword">this</span>.screen = screen; </span><br><span class="line">        <span class="keyword">this</span>.memory = memory; </span><br><span class="line">        <span class="keyword">this</span>.mainboard = mainboard; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewComputer</span> </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> String cpu; </span><br><span class="line">    <span class="keyword">private</span> String screen; </span><br><span class="line">    <span class="keyword">private</span> String memory; </span><br><span class="line">    <span class="keyword">private</span> String mainboard; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NewComputer</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(“can’t init”); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">NewComputer</span><span class="params">(Builder builder)</span> </span>&#123; </span><br><span class="line">        cpu = builder.cpu; </span><br><span class="line">        screen = builder.screen; </span><br><span class="line">        memory = builder.memory; </span><br><span class="line">        mainboard = builder.mainboard; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123; </span><br><span class="line">        <span class="keyword">private</span> String cpu; </span><br><span class="line">        <span class="keyword">private</span> String screen; </span><br><span class="line">        <span class="keyword">private</span> String memory; </span><br><span class="line">        <span class="keyword">private</span> String mainboard; </span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">()</span> </span>&#123;&#125; </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">cpu</span><span class="params">(String val)</span> </span>&#123; </span><br><span class="line">        cpu = val; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">screen</span><span class="params">(String val)</span> </span>&#123; </span><br><span class="line">        screen = val; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">memory</span><span class="params">(String val)</span> </span>&#123; </span><br><span class="line">        memory = val; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">mainboard</span><span class="params">(String val)</span> </span>&#123; </span><br><span class="line">        mainboard = val; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> NewComputer <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span>  NewComputer(<span class="keyword">this</span>);&#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h5 id="7-客户端："><a href="#7-客户端：" class="headerlink" title="7  客户端："></a>7  客户端：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Click</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">        <span class="comment">// 非 Builder 模式 </span></span><br><span class="line">        Computer computer = <span class="keyword">new</span> Computer(“cpu”, “screen”, “memory”, “mainboard”); </span><br><span class="line">        <span class="comment">// Builder 模式 </span></span><br><span class="line">        NewComputer newComputer = <span class="keyword">new</span> NewComputer.Builder() </span><br><span class="line">        .cpu(“cpu”) </span><br><span class="line">        .screen(“screen”) </span><br><span class="line">        .memory(“memory”) </span><br><span class="line">        .mainboard(“mainboard”) </span><br><span class="line">        .build(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面的示例代码只是传入四个参数，如果参数是十四个甚至更多，builder 模式的优势将会更加明显，传递参数更加灵活，代码具有更高的可读性. </p>
</blockquote>
<h4 id="6-4-优缺点比较"><a href="#6-4-优缺点比较" class="headerlink" title="6.4.优缺点比较"></a>6.4.优缺点比较</h4><blockquote>
<p>一般的套路：优点是比较简单，开发效率高，缺点是如果参数真的很多的话鬼知道每个对应的是什么意思啊。</p>
</blockquote>
<blockquote>
<p>Builder模式：优点是可以将构造器的setter方法名取成类似注释的方式，这样我们可以很清晰的知道刚才究竟设置的什么值，可读性较高，缺点是比较冗长。</p>
</blockquote>
<h5 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h5><ul>
<li>使用建造者模式可以使客户端不必知道产品内部组成的细节。</li>
<li>具体的建造者类之间是相互独立的，这有利于系统的扩展。</li>
<li>具体的建造者相互独立，因此可以对建造的过程逐步细化，而不会对其他模块产生任何影响。</li>
</ul>
<h5 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h5><ul>
<li>建造者模式所创建的产品一般具有较多的共同点，其组成部分相似；如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。</li>
<li>如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。</li>
</ul>
<h4 id="6-5-建造者模式与抽象工厂模式的比较"><a href="#6-5-建造者模式与抽象工厂模式的比较" class="headerlink" title="6.5.建造者模式与抽象工厂模式的比较:"></a>6.5.建造者模式与抽象工厂模式的比较:</h4><ul>
<li><p>与抽象工厂模式相比，建造者模式返回一个组装好的完整产品，而抽象工厂模式返回一系列相关的产品，这些产品位于不同的产品等级结构，构成了一个产品族 。</p>
</li>
<li><p>在抽象工厂模式中，客户端实例化工厂类，然后调用工厂方法获取所需产品对象，而在建造者模式中，客户端可以不直接调用建造者的相关方法，而是通过指挥者类来指导如何生成对象，包括对象的组装过程和建造步骤，它侧重于一步步构造一个复杂对象，返回一个完整的对象 。</p>
</li>
<li><p>如果将抽象工厂模式看成汽车配件生产工厂，生产一个产品族的产品，那么建造者模式就是一个汽车组装工厂，通过对部件的组装可以返回一辆完整的汽车</p>
</li>
</ul>
<h3 id="7-抽象工厂模式"><a href="#7-抽象工厂模式" class="headerlink" title="7 抽象工厂模式"></a>7 抽象工厂模式</h3><h4 id="7-0-抽象工厂模式"><a href="#7-0-抽象工厂模式" class="headerlink" title="7.0 抽象工厂模式"></a>7.0 抽象工厂模式</h4><ul>
<li>==<strong>定义</strong>==:抽象工厂模式提供了一个创建一系列相关或者相互依赖对象的接口，<strong>无需指定它们具体的类</strong></li>
<li>==<strong>适用场景</strong>==:<ol>
<li><strong>客户端</strong>(应用层)<strong>不依赖于产品类实例</strong>如何被创建、实现等细节</li>
<li>强调一系列相关的产品对象(属于同一产品族) 一起使用创建对象需要大量的重复代码</li>
<li>提供一个产品类的库，所有的产品以同样的接口出现，从而使得客户端不依赖于具体的实现</li>
</ol>
</li>
<li>==<strong>优点</strong>==:<ul>
<li>具体产品在应用层的代码隔离，无需关心创建的细节</li>
<li>将一个系列的产品统一到一起创建</li>
</ul>
</li>
<li>==<strong>缺点</strong>==:<ul>
<li>规定了所有可能被创建的产品集合，产品簇中扩展新的产品困难;</li>
<li>增加了系统的抽象性和理解难度</li>
</ul>
</li>
<li><img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/1584889615031.png" alt="1584889615031" style="zoom: 67%;float:left" / loading="lazy"></li>
<li><img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/1584628677957.png" alt="1584628677957" style="zoom:67%;float:left" / loading="lazy"></li>
<li><img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/1584629249484.png" alt="1584629249484" style="zoom: 67%;float:left" / loading="lazy"></li>
</ul>
<h4 id="7-1-抽象工厂模式定义"><a href="#7-1-抽象工厂模式定义" class="headerlink" title="7.1 抽象工厂模式定义"></a>7.1 抽象工厂模式定义</h4><ul>
<li>抽象工厂模式可以说是是工厂方法模式的升级版，当需要创建的产品<strong>有多个产品线（产品族）</strong>时使用抽象工厂模式是比较好的选择。</li>
<li>我们一直都是生产联想和惠普的电脑，但是电脑也有多个产品线：<strong>台式机、笔记本和平板</strong>等等，联想和惠普都在生产这些不同产品线上的电脑，使用工厂方法模式已经满足不了需求，这一篇文章我们就用抽象工厂模式来解决这一问题。</li>
</ul>
<h5 id="1-1-抽象工厂模式定义"><a href="#1-1-抽象工厂模式定义" class="headerlink" title="1.1 抽象工厂模式定义"></a>1.1 抽象工厂模式定义</h5><ul>
<li>为创建一组相关或者相互依赖的对象提供一个接口，而无需指定它们的具体类。</li>
</ul>
<h5 id="1-2-抽象工厂模式UML图"><a href="#1-2-抽象工厂模式UML图" class="headerlink" title="1.2 抽象工厂模式UML图"></a>1.2 抽象工厂模式UML图</h5><p> <img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/5982616-094e351888095369.png" alt="img" loading="lazy"> </p>
<p>在抽象工厂模式中有如下角色：</p>
<ul>
<li>AbstractFactory：抽象工厂，它声明了用来创建不同产品的方法。</li>
<li>ConcreteFactory：具体工厂，实现抽象工厂中定义的创建产品的方法。</li>
<li>AbstractProduct：抽象产品，为每种产品声明业务方法。比如上图的AbstractProductA和 AbstractProductB。</li>
<li>ConcreteProduct：具体产品，定义具体工厂生产的具体产品，并实现抽象产品中定义的业务方法。</li>
</ul>
<h4 id="7-2-抽象工厂模式简单实现"><a href="#7-2-抽象工厂模式简单实现" class="headerlink" title="7.2 抽象工厂模式简单实现"></a>7.2 抽象工厂模式简单实现</h4><p>联想和惠普生产的电脑分为了两个产品线，一个台式机，一个是笔记本。为了解决增加产品线的问题，我们用抽象工厂模式来进行实现。</p>
<h5 id="2-1-抽象产品"><a href="#2-1-抽象产品" class="headerlink" title="2.1 抽象产品"></a>2.1 抽象产品</h5><p>首先定义抽象产品类：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">DesktopComputer</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">start</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">NotebookComputer</span> &#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">start</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两个抽象产品类分别为DesktopComputer和NotebookComputer ，用来<strong>定义两个产品线</strong>：台式机和笔记本。它们都定义了start方法，用来启动电脑。</p>
<h5 id="2-2-具体产品"><a href="#2-2-具体产品" class="headerlink" title="2.2 具体产品"></a>2.2 具体产品</h5><p>具体产品为联想和惠普旗下的台式机和笔记本，如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LenovoDesktopComputer</span> <span class="keyword">extends</span> <span class="title">DesktopComputer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;联想台式电脑启动&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HpDesktopComputer</span> <span class="keyword">extends</span> <span class="title">DesktopComputer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;惠普台式电脑启动&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LenovoNotebookComputer</span> <span class="keyword">extends</span> <span class="title">NotebookComputer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;联想笔记本电脑启动&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HpNotebookComputer</span> <span class="keyword">extends</span> <span class="title">NotebookComputer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;惠普笔记本电脑启动&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-3-抽象工厂"><a href="#2-3-抽象工厂" class="headerlink" title="2.3 抽象工厂"></a>2.3 抽象工厂</h5><p>接着创建生产电脑的抽象工厂，如下所示，</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">ComputerFactory</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> DesktopComputer <span class="title">createDesktopComputer</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> NotebookComputer <span class="title">createNotebookComputer</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义了两个方法，分别用来生产台式电脑和笔记本电脑。</p>
<h5 id="2-4-具体工厂"><a href="#2-4-具体工厂" class="headerlink" title="2.4 具体工厂"></a>2.4 具体工厂</h5><p>定义联想和惠普工厂：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LenovoFactory</span> <span class="keyword">extends</span> <span class="title">ComputerFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DesktopComputer <span class="title">createDesktopComputer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LenovoDesktopComputer();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> NotebookComputer <span class="title">createNotebookComputer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LenovoNotebookComputer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HpFactory</span> <span class="keyword">extends</span> <span class="title">ComputerFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DesktopComputer <span class="title">createDesktopComputer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HpDesktopComputer();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> NotebookComputer <span class="title">createNotebookComputer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HpNotebookComputer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>联想工厂和惠普工厂用来生产台式机和笔记本这两个不同产品线的电脑。</p>
<h5 id="2-5-客户端调用"><a href="#2-5-客户端调用" class="headerlink" title="2.5 客户端调用"></a>2.5 客户端调用</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span> </span>&#123;</span><br><span class="line">        ComputerFactory lenocoFactory=<span class="keyword">new</span> LenovoFactory();</span><br><span class="line">        lenocoFactory.createDesktopComputer().start();</span><br><span class="line">        lenocoFactory.createNotebookComputer().start();</span><br><span class="line">        ComputerFactory hpFactory=<span class="keyword">new</span> HpFactory();</span><br><span class="line">        hpFactory.createDesktopComputer().start();</span><br><span class="line">        hpFactory.createNotebookComputer().start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 接下来给出这个例子的UML图，更便于理解，如下所示。 </p>
 <img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/5982616-2973c44a89da88ba.png" alt="img" style="zoom: 67%;" / loading="lazy"> 

<h4 id="7-3-优点和缺点"><a href="#7-3-优点和缺点" class="headerlink" title="7.3 优点和缺点"></a>7.3 优点和缺点</h4><h5 id="3-1-优点"><a href="#3-1-优点" class="headerlink" title="3.1 优点"></a>3.1 优点</h5><ul>
<li>抽象工厂模式隔离了具体类的生成，使得客户并不需要知道什么被创建。由于这种隔离，更换一个具体工厂就变得相对容易。所有的具体工厂都实现了抽象工厂中定义的那些公共接口，因此只需改变具体工厂的实例，就可以在某种程度上改变整个软件系统的行为。另外，应用抽象工厂模式可以实现高内聚低耦合的设计目的，因此抽象工厂模式得到了广泛的应用。</li>
<li>当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象。这对一些需要根据当前环境来决定其行为的软件系统来说，是一种非常实用的设计模式。</li>
<li>增加新的具体工厂和产品族很方便，无须修改已有系统，符合“开闭原则”。</li>
</ul>
<h5 id="3-2-缺点"><a href="#3-2-缺点" class="headerlink" title="3.2 缺点"></a>3.2 缺点</h5><ul>
<li>在添加新的产品对象时，难以扩展抽象工厂来生产新种类的产品，这是因为在抽象工厂角色中规定了所有可能被创建的产品集合，<strong>要支持新种类的产品就意味着要对该接口进行扩展，而这将涉及到对抽象工厂角色及其所有子类的修改，显然会带来较大的不便</strong>。</li>
<li>开闭原则的倾斜性<br> (1) 增加产品族：对于增加新的产品族，抽象工厂模式很好地支持了“开闭原则”，只需要增加具体产品并对应增加一个新的具体工厂，对已有代码无须做任何修改。<br> (2) 增加新的产品等级结构：对于增加新的产品等级结构，需要修改所有的工厂角色，包括抽象工厂类，在所有的工厂类中都需要增加生产新产品的方法，违背了“开闭原则”。</li>
</ul>
<p>正因为抽象工厂模式存在“开闭原则”的倾斜性，它以一种倾斜的方式来满足“开闭原则”，为增加新产品族提供方便，但不能为增加新产品结构提供这样的方便，因此要求设计人员在设计之初就能够全面考虑，不会在设计完成之后向系统中增加新的产品等级结构，也不会删除已有的产品等级结构，否则将会导致系统出现较大的修改，为后续维护工作带来诸多麻烦。</p>
<h4 id="7-4-适用环境"><a href="#7-4-适用环境" class="headerlink" title="7.4 适用环境"></a>7.4 适用环境</h4><p>在以下情况下可以考虑使用抽象工厂模式：</p>
<ul>
<li>一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有类型的工厂模式都是很重要的，用户无须关心对象的创建过程，将对象的创建和使用解耦。</li>
<li>系统中有多于一个的产品族，而每次只使用其中某一产品族。可以通过配置文件等方式来使得用户可以动态改变产品族，也可以很方便地增加新的产品族。</li>
<li>属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来。同一个产品族中的产品可以是没有任何关系的对象，但是它们都具有一些共同的约束，如同一制作水果蛋糕用的水果–草莓和芒果，草莓和芒果之间没有直接关系，但它们都是属于水果。</li>
<li>产品等级结构稳定，设计完成之后，不会向系统中增加新的产品等级结构或者删除已有的产品等级结构。</li>
</ul>
<h4 id="7-5-模式扩展"><a href="#7-5-模式扩展" class="headerlink" title="7.5 模式扩展"></a>7.5 模式扩展</h4><p><strong>“开闭原则”的倾斜性</strong><br> “开闭原则”要求系统对扩展开放，对修改封闭，通过扩展达到增强其功能的目的。对于涉及到多个产品族与多个产品等级结构的系统，其功能增强包括两方面：</p>
<ul>
<li>增加产品族：对于增加新的产品族，工厂方法模式很好的支持了“开闭原则”，对于新增加的产品族，只需要对应增加一个新的具体工厂即可，对已有代码无须做任何修改。</li>
<li>增加新的产品等级结构：对于增加新的产品等级结构，需要修改所有的工厂角色，包括抽象工厂类，在所有的工厂类中都需要增加生产新产品的方法，不能很好地支持“开闭原则”。</li>
</ul>
<p><strong>工厂模式的退化</strong></p>
<ul>
<li>当抽象工厂模式中每一个具体工厂类只创建一个产品对象，也就是只存在一个产品等级结构时，抽象工厂模式退化成工厂方法模式；</li>
<li>当工厂方法模式中抽象工厂与具体工厂合并，提供一个统一的工厂来创建产品对象，并将创建对象的工厂方法设计为静态方法时，工厂方法模式退化成简单工厂模式。</li>
</ul>
<h3 id="8-单例模式"><a href="#8-单例模式" class="headerlink" title="8 单例模式"></a>8 单例模式</h3><p>==首先要了解三个问题？== 代码中存在这三个基础知识</p>
<ul>
<li><p><strong>==什么是枚举==</strong></p>
<ol>
<li>其实枚举就是在一个类里定义几个静态变量，每个变量都是这个类的实例。<ul>
<li> 枚举简单的说也是一种数据类型，只不过是这种数据类型只包含自定义的特定数据，它是一组有共同特性的数据的集合。</li>
<li>举个例子，颜色也可以定义成<a target="_blank" rel="noopener" href="https://www.baidu.com/s?wd=%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao">枚举类型</a>，它可以包含你定义的任何颜色，当需要的时候，只需要通过枚举调用即可，</li>
<li>另外比如说季节（<a target="_blank" rel="noopener" href="https://www.baidu.com/s?wd=%E6%98%A5%E5%A4%8F%E7%A7%8B%E5%86%AC&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao">春夏秋冬</a>）、星期（<a target="_blank" rel="noopener" href="https://www.baidu.com/s?wd=%E6%98%9F%E6%9C%9F%E4%B8%80&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao">星期一</a>到星期日）等等这些具有共同投特征的数据都可以定义枚举。  </li>
</ul>
</li>
<li>比如说，类Human有两个静态变量：Man,Woman，每一个变量都是Human类的实例。</li>
<li>用的时候就直接写Human.Man，Human.Woman，用的时候就直接用Human.Man.hasXJJ()或者Human.Woman.hasXJJ()方法，这不就是枚举么。</li>
<li>作用么，其实就是提供常量。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">private static Hungry instance=new Hungry ();</span></span><br><span class="line"><span class="comment">public static Hungry getInstance() &#123;</span></span><br><span class="line"><span class="comment">    return instance;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line">INSTANCE;</span><br><span class="line"><span class="function"><span class="keyword">private</span> EnumSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>==<strong>什么是反射</strong>==</p>
<ol>
<li> JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法，</li>
<li>对于任意一个对象，都能够调用它的任意一个方法和属性，</li>
<li>这种==动态获取==的信息以及==动态调用==对象的方法的功能称为java语言的反射机制。</li>
<li>==Class类== <ul>
<li>这个类用于操纵（反向解析）一个类的属性，方法，构造器等。</li>
<li>Person: name,age,address(Class只要知道你这个Person类，那么它便可知道你所有的属性，不止属性，甚至方法上的注解等等，都会知道。) </li>
</ul>
</li>
</ol>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/26954130"><strong>==什么是内部类==</strong></a> </p>
</li>
</ul>
<h4 id="0-单例模式探究"><a href="#0-单例模式探究" class="headerlink" title="==0 单例模式探究=="></a>==0 单例模式探究==</h4><p><strong>所谓单例，就是整个程序有且仅有一个实例。该类负责创建自己的对象，同时确保只有一个对象被创建。在Java，一般常用在工具类的实现或创建对象需要消耗资源。</strong></p>
<p><strong>特点</strong> </p>
<ul>
<li><p>类构造器私有</p>
</li>
<li><p>持有自己类型的属性</p>
</li>
<li><p>对外提供获取实例的静态方法</p>
</li>
</ul>
<h5 id="1-核心作用"><a href="#1-核心作用" class="headerlink" title="==1 核心作用==:"></a>==1 核心作用==:</h5><p><strong>保证一个类只有一个实例，并且提供一个访问该实例的全局访问点</strong> </p>
<h5 id="2-常见场景"><a href="#2-常见场景" class="headerlink" title="==2 常见场景==:"></a>==2 常见场景==:</h5><ul>
<li><p>Windows的任务管理器</p>
</li>
<li><p>Windows的回收站：打开一个窗口，再打开一个就不能打开了。</p>
<img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/1584153759373.png" alt="1584153759373" style="zoom: 67%;float:left" / loading="lazy"></li>
<li><p>项目中，读取配置文件的类，一般也只有一个对象，没必要每次都去new对象读取</p>
</li>
<li><p>网站的计数器一般也会采用单例模式，可以保证同步</p>
</li>
<li><p>数据库连接池的设计一般也是单例模式</p>
</li>
<li><p>在Servlet编程中， 每个Servlet也是单例的</p>
</li>
<li><p>在Spring中, 每个Bean默认就是单例的<br>…… </p>
</li>
</ul>
<h5 id="3-优点"><a href="#3-优点" class="headerlink" title="==3 优点==:"></a>==3 优点==:</h5><ul>
<li>由于单例模式只生成一个实例， 减少了系统性能开销。</li>
<li>单例模式可以在系统设置全局的访问点，优化共享资源访问。</li>
<li>单例模式可以说只要是一个合格的开发都会写，但是如果要深究，小小的单例模式可以牵扯到很多东西</li>
</ul>
<h5 id="4-常见的五种单例模式实现方式"><a href="#4-常见的五种单例模式实现方式" class="headerlink" title="==4 常见的五种单例模式实现方式==:"></a>==4 常见的五种单例模式实现方式==:</h5><ol>
<li><p><strong>==饿汉式==（线程安全，调用效率高，不能延时加载）</strong> ：如果我们写的代码没有不使用的代码，没有开辟内存空间，可以使用这种模式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> singleton;</span><br><span class="line"><span class="comment">//饿汉式单例:运行时，立即加载</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hungry</span> </span>&#123;</span><br><span class="line"><span class="comment">//	在虚拟机中创建空间，如果不使用这个方法，也会创建空间，则造成浪费，</span></span><br><span class="line"><span class="comment">//	所以有了懒汉式单例：使用时，才会加载；不使用，不加载</span></span><br><span class="line">	<span class="keyword">byte</span>[] by=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">	<span class="keyword">byte</span>[] by2=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">	</span><br><span class="line"><span class="comment">//	私有化构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Hungry</span><span class="params">()</span></span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//	类初始化的时候，立即加载该对象</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Hungry instance=<span class="keyword">new</span> Hungry ();</span><br><span class="line"><span class="comment">//	提供获取该对象的方法，没有synchronized，效率高</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Hungry <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HungryTest</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Hungry instance = Hungry.getInstance();</span><br><span class="line">		Hungry instance2 = Hungry.getInstance();</span><br><span class="line">		System.out.println(<span class="string">&quot;Hungry&quot;</span>);</span><br><span class="line">		System.out.println(instance==instance2);<span class="comment">//true</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>==懒汉式==（线程安全，调用效率不高，可以延时加载）</strong> ：如果需要开辟很多空间，而且有时候觉得浪费，可以使用延时加载</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> singleton;</span><br><span class="line"><span class="comment">//懒汉式单例：没有在类一加载的时候，就创建，</span></span><br><span class="line"><span class="comment">//使用时，才会加载；不使用，不加载</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lazy</span> </span>&#123;</span><br><span class="line"><span class="comment">//	私有化构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Lazy</span><span class="params">()</span></span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//	类初始化的时候，不立即加载该对象</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Lazy instance;</span><br><span class="line"><span class="comment">//	提供获取该对象的方法，有synchronized（防止有多个线程进来，所有就要让它们排队），效率低</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Lazy <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (instance==<span class="keyword">null</span>) &#123;</span><br><span class="line">			instance=<span class="keyword">new</span> Lazy();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LazyTest</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Lazy instance = Lazy.getInstance();</span><br><span class="line">		Lazy instance2 = Lazy.getInstance();</span><br><span class="line">		System.out.println(<span class="string">&quot;Lazy&quot;</span>);</span><br><span class="line">		System.out.println(instance==instance2);<span class="comment">//true</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/Heliner/p/10524876.html">==DCL懒汉式==</a></strong> （由于JVM底层内部模型原因，偶尔会出现问题，不建议使用） ：基于DCL双锁机制的懒汉模式：</p>
<p>优化了懒汉式同步慢的问题，加了volatile关键词保证了原子性，一致性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> singleton;</span><br><span class="line"><span class="comment">//DCL懒汉式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DCLLazy</span> </span>&#123;</span><br><span class="line"><span class="comment">//	私有化构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">DCLLazy</span><span class="params">()</span></span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//	类初始化的时候，不立即加载该对象</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> DCLLazy instance;</span><br><span class="line"><span class="comment">//	提供获取该对象的方法，没有synchronized，由于不使用synchronized修饰方法，效率高，锁的比较详细</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DCLLazy <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">/*对象为空，锁定当前对象*/</span></span><br><span class="line">		<span class="keyword">if</span> (instance==<span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">synchronized</span>(DCLLazy.class)&#123;</span><br><span class="line">				<span class="comment">/*对象还是为空，创建对象*/</span></span><br><span class="line">				<span class="keyword">if</span> (instance==<span class="keyword">null</span>) &#123;</span><br><span class="line">					instance=<span class="keyword">new</span> DCLLazy();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//1. 分配内存</span></span><br><span class="line">	<span class="comment">//2. 执行构造方法</span></span><br><span class="line">	<span class="comment">//3. 指向地址</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DCLLazyTest</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		DCLLazy instance = DCLLazy.getInstance();</span><br><span class="line">		DCLLazy instance2 = DCLLazy.getInstance();</span><br><span class="line">		System.out.println(<span class="string">&quot;DCLLazy&quot;</span>);</span><br><span class="line">		System.out.println(instance==instance2);<span class="comment">//true</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>==<strong>饿汉式改进</strong>==：==静态内部类==式（线程安全，调用效率高，可以延时加载） ：相比这前四种来说，是很优秀的，但是使用反射把这前四种都可以存在破坏</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">//使用内部类：不会一运行就加载；static final保证了内存中只有这一个存在</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton instance=<span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> InnerClass.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingletonTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> </span>&#123;</span><br><span class="line">        Singleton instance = Singleton.getInstance();</span><br><span class="line">        Singleton instance2 = Singleton.getInstance();</span><br><span class="line">        System.out.println(instance==instance2);<span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="反射破坏单例"><a href="#反射破坏单例" class="headerlink" title="==反射破坏单例=="></a>==反射破坏单例==</h5><ul>
<li>破坏一：实例化对象/用反射创建对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类名.class：在这个Class对象中，保存着实例化该类时所需要的基本信息，</span></span><br><span class="line"><span class="comment">//A.class其实返回的是一个类A的Class对象，</span></span><br><span class="line"><span class="comment">// 使用反射机制，可以把private关键词破坏:可以破坏我们以上的单例</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingletonTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//实例化对象</span></span><br><span class="line">        Singleton instance = Singleton.getInstance();        </span><br><span class="line">     	<span class="comment">//用反射创建对象</span></span><br><span class="line">        Constructor&lt;Singleton&gt; constructor = Singleton.class.</span><br><span class="line">            getDeclaredConstructor(<span class="keyword">null</span>);</span><br><span class="line">        constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Singleton newInstance = constructor.newInstance();</span><br><span class="line">        </span><br><span class="line">        System.out.println(instance==newInstance);</span><br><span class="line">        System.out.println(instance.hashCode());</span><br><span class="line">        System.out.println(newInstance.hashCode());</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * false</span></span><br><span class="line"><span class="comment">         * 1326857436</span></span><br><span class="line"><span class="comment">		 * 1022736404</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解决方法一：在私有化构造器加上synchronized，用来监视这个类</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Lazy</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//监视这个类有没有反射，如果有，抛出异常</span></span><br><span class="line">    <span class="keyword">synchronized</span> (Lazy.class) &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;不要企图使用反射破坏&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>破坏二：用两个反射创建对象：解决方法一无效，不能抛出异常</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LazyTest</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//		Lazy instance = Lazy.getInstance();</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        Constructor&lt;Lazy&gt; constructor = Lazy.class.getDeclaredConstructor(<span class="keyword">null</span>);</span><br><span class="line">        constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Lazy newInstance = constructor.newInstance();</span><br><span class="line">        System.out.println(newInstance.hashCode());</span><br><span class="line">        System.out.println(<span class="string">&quot;==========&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        Lazy newInstance2 = constructor.newInstance();</span><br><span class="line">        System.out.println(newInstance2.hashCode());</span><br><span class="line">        System.out.println(newInstance2==newInstance);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 1321522194</span></span><br><span class="line"><span class="comment">        * ==========</span></span><br><span class="line"><span class="comment">        * 1547637284</span></span><br><span class="line"><span class="comment">        * false</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解决方法二：使用Boolean判断：抛出异常</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> flag=<span class="keyword">false</span>;</span><br><span class="line"><span class="comment">//	私有化构造器</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Lazy</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//监视这个类有没有反射</span></span><br><span class="line">    <span class="keyword">synchronized</span> (Lazy.class) &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag==<span class="keyword">false</span>) &#123;</span><br><span class="line">            flag=<span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;不要企图使用反射破坏&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*866891806</span></span><br><span class="line"><span class="comment">==========</span></span><br><span class="line"><span class="comment">异常*/</span></span><br></pre></td></tr></table></figure>

<ul>
<li>除了==反射==；==反序列化==也能破坏它：把这个对象序列化一个文本上，再反序列化出来，private依旧没有作用；所以还有第五种方式：==枚举==单例</li>
</ul>
</li>
<li><p>==<strong>枚举单例</strong>==（线程安全，调用效率高，不能延时加载） ：不能被反射破坏，如果使用反射，直接抛出异常；但是也有弊端：不能延时加载</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//目前最推荐的单例模式的写法</span></span><br><span class="line"><span class="comment">//纯天然枚举对象，不会被反射破坏掉</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">EnumSingleton</span> </span>&#123;</span><br><span class="line">	INSTANCE;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> EnumSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> INSTANCE;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EnumSingletonTest</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		EnumSingleton instance = EnumSingleton.INSTANCE;</span><br><span class="line">		EnumSingleton instance2 = EnumSingleton.INSTANCE;</span><br><span class="line">		System.out.println(instance==instance2);<span class="comment">//true</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="1-懒汉模式"><a href="#1-懒汉模式" class="headerlink" title="1 懒汉模式"></a>1 懒汉模式</h4><p>线程不安全，延迟初始化，严格意义上不是不是单例模式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-饿汉模式"><a href="#2-饿汉模式" class="headerlink" title="2 饿汉模式"></a>2 饿汉模式</h4><p>线程安全，比较常用，但容易产生垃圾，因为一开始就初始化 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-双重锁模式"><a href="#3-双重锁模式" class="headerlink" title="3 双重锁模式"></a>3 双重锁模式</h4><p>线程安全，延迟初始化。这种方式采用双锁机制，安全且在多线程情况下能保持高性能。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton.class) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  </span><br><span class="line">            singleton = <span class="keyword">new</span> Singleton();  </span><br><span class="line">        &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> singleton;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>双重检查模式，进行了两次的判断，第一次是为了避免不要的实例，第二次是为了进行同步，避免多线程问题。</li>
<li>由于<code>singleton=new Singleton()</code>对象的创建在JVM中可能会进行重排序，在多线程访问下存在风险，使用<code>volatile</code>修饰<code>signleton</code>实例变量有效，解决该问题。</li>
</ul>
<h4 id="4-静态内部类单例模式"><a href="#4-静态内部类单例模式" class="headerlink" title="4 静态内部类单例模式"></a>4 静态内部类单例模式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> Inner.instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<ul>
<li>只有第一次调用getInstance方法时，虚拟机才加载 Inner 并初始化instance ，只有一个线程可以获得对象的初始化锁，其他线程无法进行初始化，保证对象的唯一性。</li>
<li>目前此方式是所有单例模式中最推荐的模式，但具体还是根据项目选择。</li>
</ul>
<h4 id="5-枚举单例模式"><a href="#5-枚举单例模式" class="headerlink" title="5 枚举单例模式"></a>5 枚举单例模式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认枚举实例的创建是线程安全的，并且在任何情况下都是单例。实际上</p>
<ul>
<li>枚举类隐藏了私有的构造器。</li>
<li>枚举类的域 是相应类型的一个实例对象<br> 那么枚举类型日常用例是这样子的：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Singleton</span>  </span>&#123;</span><br><span class="line">    INSTANCE </span><br><span class="line"> </span><br><span class="line">    <span class="comment">//doSomething 该实例支持的行为</span></span><br><span class="line">      </span><br><span class="line">    <span class="comment">//可以省略此方法，通过Singleton.INSTANCE进行操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton get <span class="title">Instance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Singleton.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>枚举单例模式在《Effective Java》中推荐的单例模式之一。</p>
</li>
<li><p>但枚举实例在日常开发是很少使用的，就是很简单以导致可读性较差。</p>
</li>
<li><p>在以上所有的单例模式中，推荐静态内部类单例模式。</p>
</li>
<li><p>主要是非常直观，即保证线程安全又保证唯一性。</p>
</li>
<li><p>众所周知，单例模式是创建型模式，都会新建一个实例。</p>
</li>
<li><p>那么一个重要的问题就是反序列化。当实例被写入到文件到反序列化成实例时，我们需要重写<code>readResolve</code>方法，以让实例唯一。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="9-设计模式彩图"><a href="#9-设计模式彩图" class="headerlink" title="9 设计模式彩图"></a>9 设计模式彩图</h3><p> <img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/2799767-5a0e372d3b886348.webp" alt="img" loading="lazy"> </p>
</div><div id="reward-container"><span class="hty-icon-button button-glow" id="reward-button" title="Donate" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === &quot;none&quot;) ? &quot;block&quot; : &quot;none&quot;;"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-hand-coin-line"></use></svg></span><div id="reward-comment">I'm so cute. Please give me money.</div><div id="qr" style="display:none;"><div style="display:inline-block"><a target="_blank" rel="noopener" href="https://i.loli.net/2021/07/27/kcALMgvjIFhKVfH.jpg"><img loading="lazy" src="https://i.loli.net/2021/07/27/kcALMgvjIFhKVfH.jpg" alt="支付宝" title="支付宝"></a><div><span style="color:#00A3EE"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-alipay-line"></use></svg></span></div></div><div style="display:inline-block"><a target="_blank" rel="noopener" href="https://i.loli.net/2021/07/27/oI5KPrjHLt7iOme.jpg"><img loading="lazy" src="https://i.loli.net/2021/07/27/oI5KPrjHLt7iOme.jpg" alt="QQ 支付" title="QQ 支付"></a><div><span style="color:#12B7F5"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-qq-line"></use></svg></span></div></div><div style="display:inline-block"><a target="_blank" rel="noopener" href="https://i.loli.net/2021/07/27/PCJNbqAlHpGWKEV.jpg"><img loading="lazy" src="https://i.loli.net/2021/07/27/PCJNbqAlHpGWKEV.jpg" alt="微信支付" title="微信支付"></a><div><span style="color:#2DC100"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-wechat-pay-line"></use></svg></span></div></div></div></div><ul class="post-copyright"><li class="post-copyright-author"><strong>Post author: </strong>John Doe</li><li class="post-copyright-link"><strong>Post link: </strong><a href="http://example.com/2021/07/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="设计模式">http://example.com/2021/07/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</a></li><li class="post-copyright-license"><strong>Copyright Notice: </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><svg class="icon"><use xlink:href="#icon-creative-commons-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-by-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-nc-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-sa-line"></use></svg></a> unless otherwise stated.</li></ul></section></article><div class="post-nav"><div class="post-nav-item"><a class="post-nav-prev" href="/2021/07/28/%E9%A1%B9%E7%9B%AE%E8%A7%84%E5%88%99/" rel="prev" title="项目规则"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-left-s-line"></use></svg><span class="post-nav-text">项目规则</span></a></div><div class="post-nav-item"><a class="post-nav-next" href="/2021/07/28/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/" rel="next" title="前后端分离"><span class="post-nav-text">前后端分离</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-right-s-line"></use></svg></a></div></div></div><div class="hty-card" id="comment"><div class="comment-tooltip text-center"><span>要不要和我说些什么？</span><br></div></div></main><footer class="sidebar-translate" id="footer"><div class="copyright"><span>&copy; 2019 – 2021 </span><span class="with-love" id="animate"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-cloud-line"></use></svg></span><span class="author"> John Doe</span></div><div class="powered"><span>Powered by <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> v5.4.0</span><span class="footer-separator">|</span><span>Theme - <a rel="noopener" href="https://github.com/YunYouJun/hexo-theme-yun" target="_blank"><span>Yun</span></a> v1.6.1</span></div><div class="live_time"><span>本博客已萌萌哒地运行</span><span id="display_live_time"></span><span class="moe-text">(●'◡'●)</span><script>function blog_live_time() {
  setTimeout(blog_live_time, 1000);
  const start = new Date('2021-06-17T00:00:00');
  const now = new Date();
  const timeDiff = (now.getTime() - start.getTime());
  const msPerMinute = 60 * 1000;
  const msPerHour = 60 * msPerMinute;
  const msPerDay = 24 * msPerHour;
  const passDay = Math.floor(timeDiff / msPerDay);
  const passHour = Math.floor((timeDiff % msPerDay) / 60 / 60 / 1000);
  const passMinute = Math.floor((timeDiff % msPerHour) / 60 / 1000);
  const passSecond = Math.floor((timeDiff % msPerMinute) / 1000);
  display_live_time.innerHTML = " " + passDay + " 天 " + passHour + " 小时 " + passMinute + " 分 " + passSecond + " 秒";
}
blog_live_time();
</script></div></footer><a class="hty-icon-button" id="back-to-top" aria-label="back-to-top" href="#"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-up-s-line"></use></svg><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#0078E7" stroke-width="2" stroke-linecap="round"></circle></svg></a></div></body></html>